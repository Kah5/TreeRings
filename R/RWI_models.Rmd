---
title: "BAI_models"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rjags)
library(ggplot2)
library(caTools)
library(ggridges)
library(tidyr)
library(reshape2)
library(dplyr)

# some initial data checking:
full.ghcn <- read.csv("outputs/data/rwi_age_dbh_ghcn.df")
BAI <- full.ghcn$RWI
hist(BAI)
logBAI<- hist(log(BAI)) # approximates normal when log transformed

```

# Separate Testing and Training Datasets:

# 1. initial data cleaning & checking
# 2. create dummy variables for cohort and age classes
# 3. remove NA values for lagged RWI
# 4. add in additional climate/stand information

```{r}

summary(full.ghcn)

# get all records that have all RWI and don't have negative diams or NA diams
full.ghcn <- full.ghcn[!is.na(full.ghcn$RWI) & full.ghcn$DBH > 0 & !is.na(full.ghcn$DBH),]



#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass <- as.numeric( full.ghcn$ageclass)
Age <- as.numeric( full.ghcn$Age)
n     <- length(full.ghcn$RWI)
DBH <- full.ghcn$DBH
full.ghcn$DBH.scaled = as.vector(scale(full.ghcn$DBH, center = TRUE, scale = TRUE))
site <- full.ghcn$site
SpecCode <- full.ghcn$SpecCode


rwi.ghcn <- read.csv("outputs/full_ghcn_all_months_rwi.csv")
rwi.prism <- read.csv("outputs/full_prism_all_months_rwi.csv")


# calculate JJA VPD for each year
rwi.prism$jja.VPDmax <- rowMeans(rwi.prism[,c("Month_vpdmax_6", "Month_vpdmax_7", "Month_vpdmax_8")])
rwi.prism$jja.VPDmin <- rowMeans(rwi.prism[,c("Month_vpdmin_6", "Month_vpdmin_7", "Month_vpdmin_8")])

# calculate JJA BAL for each year
rwi.prism$jja.BAL <- rowMeans(rwi.prism[,c("Month_BAL_6", "Month_BAL_7", "Month_BAL_8")])

# calculate total precip for each year
rwi.ghcn$MAP.prism <- rowSums(rwi.prism[,c("Month_pcp_1","Month_pcp_2", "Month_pcp_3","Month_pcp_4","Month_pcp_5","Month_pcp_6", "Month_pcp_7", "Month_pcp_8", "Month_pcp_9", "Month_pcp_10", "Month_pcp_11", "Month_pcp_12")])

rwi.ghcn$MAP.ghcn <- rowSums(rwi.ghcn[,c("Month_pcp_1","Month_pcp_2", "Month_pcp_3","Month_pcp_4","Month_pcp_5","Month_pcp_6", "Month_pcp_7", "Month_pcp_8", "Month_pcp_9", "Month_pcp_10", "Month_pcp_11", "Month_pcp_12")])

# make sure the prism pcp, temp values are specified in columns, so when we merge df, it won't be a huge deal:
colnames(rwi.prism)[12:59] <- paste0("prism_",colnames(rwi.prism)[12:59])
rwi.prism.sub <- rwi.prism[,!colnames(rwi.prism) %in% c("DBH", "dbhclass", "ageclass", "SpecCode", "RWI", "RWI_1", "RWI_2", "RWI_3")]
rwi.ghcn.sub <- rwi.ghcn[,!colnames(rwi.ghcn) %in% c("DBH", "dbhclass", "ageclass", "SpecCode", "RWI", "RWI_1", "RWI_2", "RWI_3")]
# merge rwi.ghcn and rwi.prism
full.clim <- merge(rwi.ghcn.sub, rwi.prism.sub, by = c("year", "site", "ID"))

# merge to full.ghcn
full.ghcn <- merge(full.ghcn, full.clim, by = c("ID", "year", "site" ))

full.ghcn$site_age <- paste0(full.ghcn$site, "-", full.ghcn$ageclass)
full.ghcn$site_age.code <- as.numeric(as.factor(full.ghcn$site_age))


#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass <- as.numeric( full.ghcn$ageclass)
Age <- as.numeric( full.ghcn$Age)
n     <- length(full.ghcn$RWI)
DBH <- full.ghcn$DBH.x
full.ghcn$DBH.scaled = as.vector(scale(full.ghcn$DBH, center = TRUE, scale = TRUE))
site <- full.ghcn$site
SpecCode <- full.ghcn$SpecCode
plot <- unique(full.ghcn$site)

# standardise predictor variables to have mean 0 and sd = 1
DI.scaled = scale(full.ghcn$JJA.pdsi, center= TRUE, scale=TRUE)
DBH.scaled = scale(full.ghcn$DBH, center= TRUE, scale=TRUE)
full.ghcn$T.scaled = as.vector(scale(full.ghcn$JUNTmax, center= TRUE, scale=TRUE))
full.ghcn$DI.scaled = as.vector(scale(full.ghcn$JJA.pdsi, center = TRUE, scale = TRUE))
full.ghcn$DBH.scaled = as.vector(scale(full.ghcn$DBH, center = TRUE, scale = TRUE))
full.ghcn$SP6.scaled = as.vector(scale(full.ghcn$SP06_6, center = TRUE, scale = TRUE))
full.ghcn$SP6.scaled = as.vector(scale(full.ghcn$SP06_6, center = TRUE, scale = TRUE))
full.ghcn$SP1.scaled = as.vector(scale(full.ghcn$SP01_6, center = TRUE, scale = TRUE))

full.ghcn$jja.VPDmax.scaled <- as.vector(scale(full.ghcn$jja.VPDmax, center = TRUE, scale = TRUE))
full.ghcn$jja.BAL.scaled <- as.vector(scale(full.ghcn$jja.BAL, center = TRUE, scale = TRUE))
full.ghcn$MAP.scaled = as.vector(scale(full.ghcn$MAP.prism, center = TRUE, scale = TRUE))

MAP.scaled <- scale(full.ghcn$MAP.prism, center = TRUE, scale = TRUE)
T.scaled <- scale(full.ghcn$JUNTmax, center= TRUE, scale=TRUE)
#full.ghcn$.scaled <- as.vector(scale(full.ghcn$MAP.prism, center = TRUE, scale = TRUE))


SP1.scaled <- scale(full.ghcn$SP01_6, center = TRUE, scale = TRUE)
SP6.scaled <- scale(full.ghcn$SP06_6, center = TRUE, scale = TRUE)



# need to define site level structures, if not already defined:

if(! "structure" %in% colnames(full.ghcn)){
  
  structure <- data.frame(site = c("AVO","BON","COR",  "ENG",  "GLA",  "GLL1", "GLL2", "GLL3","GLL4", "HIC",  "MOU",  "PLE",  "PVC",  "STC",  "TOW", "UNC" ),
                        structure = c("Forest", "Savanna", "Forest", "Forest", "Savanna", "Forest", "Savanna", "Savanna", "Forest", "Savanna", "Forest","Savanna", "Savanna", "Savanna", "Forest", "Savanna"))
full.ghcn <- merge(full.ghcn, structure, by = "site")
}



#struct.cohort and struct.cohort.code (if it doesnt alread exist)

if(! "struct.cohort" %in% colnames(full.ghcn)){

full.ghcn$struct.cohort <- paste0(full.ghcn$ageclass,"-", full.ghcn$structure)
full.ghcn$struct.cohort.code <- ifelse(full.ghcn$struct.cohort %in% "Past-Forest", 1,
       ifelse(full.ghcn$struct.cohort %in% "Modern-Forest", 2, 
               ifelse(full.ghcn$struct.cohort %in% "Past-Savanna", 3,
                     ifelse(full.ghcn$struct.cohort %in% "Modern-Savanna", 4,"NA" ))))

}





# omit NA values for RWI - 1:
ghcn.clean <- full.ghcn[!is.na(full.ghcn$RWI_1) & !is.na(full.ghcn$RWI_2) & !is.na(full.ghcn$DBH),]


# split training and testing datasets:
msk <- caTools::sample.split( ghcn.clean, SplitRatio = 3/4, group = NULL )

train.full <- ghcn.clean[msk,]
test.full <- ghcn.clean[!msk,]

# create a dataste the elimates yrs 1900-1950 for the modern and 1950-present for past:

mod.post <- full.ghcn[full.ghcn$ageclass %in% "Modern" & full.ghcn$Year >= 1950,]
past.pre <- full.ghcn[full.ghcn$ageclass %in% "Past" & full.ghcn$Year < 1950,]

sub.ghcn<- rbind(mod.post, past.pre)

msk <- caTools::sample.split( sub.ghcn, SplitRatio = 3/4, group = NULL )

train <- ghcn.clean[msk,]
test <- ghcn.clean[!msk,]

# get dry and wet years and separate by ageclass:
dry <- quantile(ghcn.clean$JJA.pdsi, 0.25) # value of the driest years
wet <- quantile(ghcn.clean$JJA.pdsi, 0.75) # value of the wettest years

pre.dry <- ghcn.clean[ghcn.clean$year < 1950 & ghcn.clean$Jul.pdsi <= dry & ghcn.clean$ageclass %in% "Past",]
pre.dry$class <- "pre-1950"
pre.dry$climclass <- "Dry_0.25"

post.dry <- ghcn.clean[ghcn.clean$year >=1950 & ghcn.clean$Jul.pdsi <= dry & ghcn.clean$ageclass %in% "Modern" ,]
post.dry$class <- "post-1950"
post.dry$climclass <- "Dry_0.25"

pre.wet <- ghcn.clean[ghcn.clean$year < 1950 & ghcn.clean$Jul.pdsi >= wet & ghcn.clean$ageclass %in% "Past",]
pre.wet$class <- "pre-1950"
pre.wet$climclass <- "Wet_0.25"
post.wet <- ghcn.clean[ghcn.clean$year >=1950 & ghcn.clean$Jul.pdsi >= wet & ghcn.clean$ageclass %in% "Modern" ,]
post.wet$class <- "post-1950"
post.wet$climclass <- "Wet_0.25"

# combine the pre and post dry data sets:
dry.yrs <- rbind(post.dry, pre.dry)
msk <- sample.split( dry.yrs, SplitRatio = 3/4, group = NULL )

train.dry <- dry.yrs[msk,]
test.dry <- dry.yrs[!msk,]


#---------------Develop test and training sets for the stable isotope data-------------------
# read in the d13 data:


d13 <- read.csv("outputs/stable_isotopes/merged_d13_growth.csv")
d13 <- d13[!is.na(d13$DBH),]

full.iso <- merge(ghcn.clean, d13[,c("site", "ID", "year","Cor.d13C.suess", "iWUE")], by = c("site", "ID", "year"), all.x = TRUE)


full.iso$iWUE.scaled <- as.numeric(scale(full.iso$iWUE))
d13index <- !is.na(full.ghcn$Cor.d13C.suess)

# split into testing and training:
library(caTools)
#full.iso <- full.ghcn[!is.na(full.ghcn$iWUE) & !full.ghcn$site %in% "BON",]
#full.iso <- full.ghcn
iWUE.med <- full.iso %>% group_by(struct.cohort, struct.cohort.code) %>% summarise(iWUEmean = median(iWUE, na.rm =TRUE))
msk <- sample.split( full.iso, SplitRatio = 3/4, group = NULL )

train.iso <- full.iso[msk,]
test.iso <- full.iso[!msk,]



```



## Initial bayesian linear regression of climate on Basal Area Index
# this model assumes all trees across all species + sites + forest types have the same relationship with PDSI
```{r}

# population model for the response of each BAI to each year of climate:
population_model <- "model{

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1 +  beta2*DI.scaled[i] + beta3*DBH.scaled[i] +  beta4*T.scaled[i] 



}

# Assume normal priors for betas (because they could be negative or positive)

beta1 ~ dnorm(0, 0.001)
beta2 ~ dnorm(0, 0.001)
beta3 ~ dnorm(0,0.001)
beta4 ~ dnorm(0,0.001)


# Non-informative Prior for the inverse variances
inv.var   ~ dgamma(0.01, 0.01)
sigma     <- 1/sqrt(inv.var)


for(i in 1:np){
# process model
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1 +  beta2*DI.scaled.p[i] + beta3*DBH.scaled.p[i] + beta4*T.scaled.p[i] # use Drought index


}


}"


# fit jags model:
reg.model.age <- jags.model(textConnection(population_model), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled,T.scaled = train$T.scaled, np = length(test$RWI), DI.scaled.p = test$DI.scaled, DBH.scaled.p = test$DBH.scaled, T.scaled.p = test$T.scaled), n.chains = 3)

update(reg.model.age, 1000); # Burnin for 1000 samples to start, then go higher later

# get samples
samp <- coda.samples(reg.model.age, 
                     variable.names=c("beta1", "beta2", "beta3", "beta4", "sigma", "Yp"), 
                    n.chains = 3, n.iter=2000)

gelman.diag(samp)
traceplot(samp)
# this still does it for Y as well
dic.reg.model.age <- dic.samples(reg.model.age, 
                     variable.names=c("beta1", "beta2", "beta3", "beta4", "sigma"), 
                    n.chains = 3, n.iter=2000,type =  "pD")

#Extract the samples for each parameter

 samps       <- samp[[1]]
 Yp.samps    <- samps[,1:length(test$X)] 
 alpha.samps <- samps[,(length(test$X)+1)]
 beta.samps  <- samps[,(length(test$X)+2):((length(test$X)+4))]
 sigma.samps <- samps[,(length(test$X)+5)]

 
# caluculate 95% CI for alpha and beta samps 
alpha.025 <- quantile(alpha.samps, 0.025)
alpha.975 <- quantile(alpha.samps, 0.975)
beta1.025 <- quantile(beta.samps[,1], 0.025)
beta1.975 <- quantile(beta.samps[,1], 0.975)
beta2.025 <- quantile(beta.samps[,2], 0.025)
beta2.975 <- quantile(beta.samps[,2], 0.975)



a <- data.frame('alpha' = alpha.samps, 'beta.drought' = beta.samps[,1], 'Beta.dbh' = beta.samps[,2], 'Beta.JunT' = beta.samps[,3])
colnames(a)<- c("alpha", "beta.drought", "beta.dbh", "beta.temp")
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))

# make dot + 95% CI plots for each param
a.mplots <- ggplot(a.m, aes(value, color = variable))+geom_density(alpha = 0.5)+theme_black()

a.m.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.m.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.m.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a.m <- data.frame(a.m.mean, a.m.lower, a.m.upper)

#plot.dat.a.m$class <- row.names(plot.dat.a.m)

a.m.dots <- ggplot(plot.dat.a.m, aes(x = a.m.mean, y = row.names(plot.dat.a.m)))+geom_errorbarh( xmin = a.m.lower, xmax = a.m.upper,height = 0, size = 2)+geom_point(size = 3)+geom_vline(xintercept = 0, linetype = "dashed")+coord_flip()+theme(legend.position = "none")+xlab("Parameter Estimates")+ylab("Parameters")+theme_bw()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg/Parameter_estimates.png")
a.m.dots
dev.off()

# plot predicted vs. observed
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps)) ~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/basic_reg/pred_vs_obs.png")
p.o.plot
dev.off()

# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "basic_reg", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

#write summary out for later comparison
write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)



# Compute the posterior mean for the plug-in predictions  

 beta.mn  <- colMeans(beta.samps)
 sigma.mn <- mean(sigma.samps)
 alpha.mn <- mean(alpha.samps) 
 
 plot(colMeans(exp(Yp.samps)), test$RWI)
 abline(a = 0, b = 1, col = "red")

 
  DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.25)
  DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.25)
 
 # something like:
 Xp <- expand.grid(DIprobe, DBHprobe)
 #Xp <- as.matrix(Xp)
# Plot the Posterior Predictive Density and plug-in
np <- length(Xp$Var1)
ypred <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   # Plug-in
   mu <- alpha.mn+sum(Xp[j,]*beta.mn)
   ypred[[j]]  <- rnorm(20000, mu, sigma.mn)
   
    
  
   # Truth
   #abline(v=mean(ypred),col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- data.frame(do.call(rbind, ypred))

Xp$MeanY <- exp(rowMeans(ypred.df)) # get the means of the posterior to plot the overall effects of DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg/Ypred_by_drought.png")
ggplot(Xp, aes(Var1, MeanY, color = Var2))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg/Ypred_by_DBH.png")
ggplot(Xp, aes(Var2, MeanY))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg/Ypred_by_drought_DBH.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)
dev.off()

#set.seed(13)
m <- 10000
chains <- samp[[1]][,1:4]
chains2 <- samp[[2]][,1:4]

postDraws <- chains[sample(nrow(chains),size=m,replace=TRUE),]



# Sample m draws of y.rep (n obs each) from likelihood p(y|theta), using thetas sampled above. Approximates posterior predictive distribution p(y.rep|y)
n <- nrow(full.ghcn)
y.rep <- matrix(NA, nrow=n, ncol=m)
for (i in 1:m){
  y.rep[,i] <- rnorm(n = n, postDraws[i,"fit"], postDraws[i,"fit.new"])
}

# check to see if the predicted yrep alighs with data y max
T1.y <- max(Y)
T1.yrep <- apply(y.rep, 2, max)
hist(T1.yrep)


abline(v=T1.y,col="red",lwd=2)


pppval.max <- sum(T1.yrep>=T1.y)/m
print(pppval.max)

# quick check to see how params compare to OLS 
summary(lm(Y ~ full.ghcn$DI.scaled))

# plot mcmc + the parameter distn
coda:::plot.mcmc(samp)
samp.basic.reg <- samp
# save a data frame with beta2 sensitivity and the 
samp.basic.reg.df <- summary(samp)
  
samp.basic.df.sum<- data.frame(mean = samp.df$statistics[2,"Mean"], 
           ci.low = samp.df$quantiles[2,"2.5%"], 
           ci.high = samp.df$quantiles[2,"97.5%"])
  


```

# Model random effects for sites for slopes and intercepts
```{r}

population_model_site_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[SITE[i]] + beta2[SITE[i]]*DI.scaled[i] + beta3[SITE[i]]*DBH.scaled[i]   # use Drought index as a scaled variable 

#res[i] <- Y[i] - gfunc[i]   
#emp.new[i] ~ dnorm(gfunc[i], sigma)
#res.new[i] <- emp.new[i] - gfunc[i]
}



# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
}

# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.0001, 0.0001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)

# predicted Y's
for(i in 1:np){
# process model
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1[SITEp[i]] + beta2[SITEp[i]]*DI.scaled.p[i] + beta3[SITEp[i]]*DBH.scaled.p[i]   # use Drought index as a scaled variable 

}




}"





reg.model.by_s <- jags.model(textConnection(population_model_site_re), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, SITE = as.numeric(train$site_age.code), S = unique(train$site_age.code), np = length(test$RWI), DI.scaled.p = test$DI.scaled, DBH.scaled.p = test$DI.scaled,SITEp = as.numeric(test$site_age.code)), n.chains = 3, n.adapt = 100)

update(reg.model.by_s, 1000); # Burnin for 1000 samples to start, then go higher later

samp.plot.re <- coda.samples(reg.model.by_s, 
                     variable.names=c("beta1", "beta2","beta3","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "Yp"), 
                    n.chains = 3, n.iter=3000)

#summary(samp.plot.re)
#plot(samp.plot.re)

#gelman.diag(samp.plot.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.plot.re[[1]]
 Yp.samps    <- samps[,1:length(test$X)] 
 alpha.samps <- samps[,(length(test$X)+1): (length(test$X)+25)]
 beta.samps  <- samps[,(length(test$X)+26):((length(test$X)+75))]
 sigma.samps <- samps[,(length(test$X)+76)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps)) ~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs.r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/basic_reg_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()

# calculate MSE & BIAS:

# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)
# write model summary output to a file!

model.summary <- data.frame(model = "basic_reg_site_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)




# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(unique(full.ghcn$site_age)[order(unique(full.ghcn$site_age.code))]))
a$num <- rownames(a)
 
a.m <- melt(a, id.vars=c("num"))
split.list <- strsplit(as.character(a.m$variable),split = "-")
split.list.df <- do.call(rbind, split.list)
a.m$site <- split.list.df[,1]
a.m$ageclass <- split.list.df[,2]
alpha.mplots <- ggplot(a.m, aes(value, fill = ageclass))+geom_density(alpha = 0.5)+theme_black()+xlab("Random Intercepts")+facet_wrap(~site)


b2 <- data.frame(beta.samps[,1:25])
colnames(b2) <- c(paste0(unique(full.ghcn$site_age)[order(unique(full.ghcn$site_age.code))]))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.m <- melt(b2, id.vars=c("num"))
split.list <- strsplit(as.character(b2.m$variable),split = "-")
split.list.df <- do.call(rbind, split.list)
b2.m$site <- split.list.df[,1]
b2.m$ageclass <- split.list.df[,2]
b2.mplots <- ggplot(b2.m, aes(value, fill = ageclass))+geom_density(alpha = 0.5)+theme_black()+xlab("Drought Index sensitivity")+facet_wrap(~site)


b2.mplots <-ggplot(b2.m, aes(value,1, fill = ageclass))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 18)+scale_fill_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))+facet_wrap(~site)

b2.mean <- apply(as.matrix(b2[,1:25]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:25]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:25]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
split.list <- strsplit(as.character(row.names(plot.dat.b2)),split = "-")
split.list.df <- do.call(rbind, split.list)
plot.dat.b2$site <- split.list.df[,1]
plot.dat.b2$ageclass <- split.list.df[,2]
#plot.dat.b2$class <- row.names(plot.dat.b2)
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels = c("Past", "Modern"))

b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")+facet_wrap(~site)

png(height = 4, width = 8, units = "in", res= 300, "outputs/growth_model/basic_reg_site_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots, b2.mplots+coord_flip() +xlim(-0.01, 0.075)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))
dev.off()
 
 
 
# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 


# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe, site = 1:16)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- rnorm(20000, mu, sigma.mn)
  # lines(density(y),col=2)

   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)

Xp$MeanY <- exp(rowMeans(ypred.df)) # get the means of the posterior to plot the overall effects of D
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_site_re/Ypred_by_drought_site.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(site)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_site_re/Ypred_by_DBH.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(site)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_site_re/Ypred_by_drought_DBH_site.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(site))
dev.off()

# since site 10 is variable, remove:

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_site_re/Ypred_by_drought_DBH_site_site_10_omitted.png")
ggplot(Xp[Xp$site != 10,], aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(site))
dev.off()


```


#this is a model with cohort effects and re effects @ the cohort level rather than the site level:

```{r}



# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_cohort_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[cohort[i]] + beta2[cohort[i]]*DI.scaled[i] + beta3[cohort[i]]*DBH.scaled[i]   # use Drought index as a scaled variable 


r1[i] <- Y[i] - gfunc[i]   
}

RSS[1] <- sum(r1^2)

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(c in 1:length(C)){
beta1[c] ~ dnorm(mu_beta1, inv_beta1)
beta2[c] ~ dnorm(mu_beta2, inv_beta2)
beta3[c] ~ dnorm(mu_beta3, inv_beta3)

r2[c] <- beta1[c] - mu_beta1
r3[c] <- beta2[c] - mu_beta2
r4[c] <- beta3[c] - mu_beta3
}


RSS[2] <- sum(r2^2)
RSS[3] <- sum(r3^2)
RSS[4] <- sum(r4^2)

# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)



  
# Contrasts:
    betadiff <- beta2[1]-beta2[2] # difference in modes of pitcher and 1st base positions
    #betadiffProb <- step(betadiff) # returns a 1 if c1Minusc3 > 0


# get Ypred for test data:
for(i in 1:np){
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1[cohort.p[i]] + beta2[cohort.p[i]]*DI.scaled.p[i] + beta3[cohort.p[i]]*DBH.scaled.p[i]   # use Drought index as a scaled variable 

}


}"






reg.model.by_age <- jags.model(textConnection(population_model_cohort_re), 
                    data = list(Y= log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, cohort = as.numeric(train$ageclass), C = unique(train$ageclass), np=length(train$year), DI.scaled.p = train$DI.scaled, DBH.scaled.p = train$DBH.scaled, cohort.p = as.numeric(train$ageclass)), n.chains = 3, n.adapt = 100)


update(reg.model.by_age, 1000); # Burnin for 1000 samples to start, then go higher later

samp.age.re <- coda.samples(reg.model.by_age, 
                     variable.names=c("beta1", "beta2","beta3","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "betadiff", "Yp", "RSS[1]", "RSS[2]", "RSS[3]", "RSS[4]"), 
                    n.chains = 3, n.iter=2000, thin = 10)

#summary(samp.age.re)
#plot(samp.age.re)

#gelman.diag(samp.age.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.age.re[[1]]
 RSS <- samps[,1:5]
 samps <- samps[,5:(length(test$year)+15)]
 Yp.samps    <- samps[,1:length(test$year)] 
 alpha.samps <- samps[,(length(test$year)+1):(length(test$year)+2)] # one alpha for each of 16 sites
 beta1.samps  <- samps[,(length(test$year)+3):(length(test$year)+4)]
 beta2.samps <- samps[,(length(test$year)+5):(length(test$year)+6)]
 beta.diff.samps <- samps[,(length(test$year)+7)]
 sigma.samps <- samps[,(length(test$year)+8)]
 sigma_betas <- samps[,(length(test$year)+9):(length(test$year)+11)]

 #RSS:
  rss0 <- function(x) crossprod(x-mean(x))
## Data level
1-mean(RSS[,1])/rss0(Y)
1-mean(RSS[,2])/rss0(Y)
1-mean(RSS[,3])/rss0(Y)
1-mean(RSS[,4])/rss0(Y)
1-mean(RSS[,5])/rss0(Y)
## Group level
1-mean(RSS[,2])/mean(apply(alpha.samps, 1, rss0))
1-mean(RSS[,3])/mean(apply(beta1.samps, 1, rss0))

# plot predicted vs. observed test data:
 png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_cohort_re/Ypred_vs_obs.png")
 plot(colMeans(exp(Yp.samps)), test$RWI, xlab = "Mean Posterior Predicted Growth", ylab = "Observed Tree Ring Growth")
 abline(a = 0, b = 1, col = "red")
 dev.off()
 
 
 
 # plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/basic_reg_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "basic_reg_cohort_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)

 
png("outputs/growth_model/basic_reg_cohort_re/marginal_alphas.png")
par(mfrow=c(1,3))
hist(alpha.samps[,1], main = "alpha Forest")
hist(alpha.samps[,2], main = "alpha Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/basic_reg_cohort_re/marginal_beta1s.png")
par(mfrow=c(1,3))
hist(beta1.samps[,1], main = "beta2 Forest")
hist(beta1.samps[,2], main = "beta2 Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()


png("outputs/growth_model/basic_reg_cohort_re/marginal_beta1_diff.png")

hist(beta1.diffs, main = "Difference between savanna and forest beta1")
abline(v=0,col="red")
dev.off()

png("outputs/growth_model/basic_reg_cohort_re/marginal_beta2s.png")
par(mfrow=c(1,3))
hist(beta2.samps[,1], main = "beta3 Forest")
hist(beta2.samps[,2], main = "beta3 Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c("Modern", "Past")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+xlab("Random Intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c("Modern", "Past")))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+xlab("Drought Index sensitivity")


b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 18)+scale_fill_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))

b2.mean <- apply(as.matrix(b2[,1:2]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:2]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:2]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)
plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c("Past", "Modern"))

b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(-0.01, 0.075)+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 4, width = 8, units = "in", res= 300, "outputs/growth_model/basic_reg_cohort_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots, b2.mplots+coord_flip() +xlim(-0.01, 0.075)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))
dev.off()


b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c("Modern", "Past")))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+xlab("DBH Index sensitivity")

library(cowplot)
png(width = 4, height = 6, units = "in", res = 300, "outputs/growth_model/basic_reg_cohort_re/param_marginal_distn_by_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()

 
# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 


# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  cohort= 1:2)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- rnorm(20000, mu, sigma.mn)
  # lines(density(y),col=2)

   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)

Xp$MeanY <- exp(rowMeans(ypred.df)) # get the means of the posterior to plot the overall effects of 
Xp$cohort <- ifelse(Xp$cohort == 1, "Past", "Modern")
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_cohort_re/Ypred_by_drought_site_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_re/Ypred_by_DBH_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")+theme_black()
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_re/Ypred_by_drought_DBH_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(cohort))+theme_black()
dev.off()


```


#this is a model with structure effects and re effects @ the structure (forest vs. savanna) level rather than the site level:

```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_structure_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[structure[i]] + beta2[structure[i]]*DI.scaled[i] + beta3[structure[i]]*DBH.scaled[i]   # use Drought index as a scaled variable 

res[i] <- Y[i] - gfunc[i]   
emp.new[i] ~ dnorm(gfunc[i], sigma)
res.new[i] <- emp.new[i] - gfunc[i]
}



# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
}

# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


for(i in 1:np){
# process model
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1[structure.p[i]] + beta2[structure.p[i]]*DI.scaled.p[i] + beta3[structure.p[i]]*DBH.scaled.p[i]   # use Drought index as a scaled variable 

}




}"





reg.model.by_structure <- jags.model(textConnection(population_model_structure_re), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, structure = as.numeric(train$structure), SF = unique(train$structure), np=length(test$year), DI.scaled.p = test$DI.scaled, DBH.scaled.p = test$DBH.scaled, structure.p = as.numeric(test$structure)), n.chains = 3, n.adapt = 100)

update(reg.model.by_structure, 1000); # Burnin for 1000 samples to start, then go higher later

samp.structure.re <- coda.samples(reg.model.by_structure, 
                     variable.names=c("beta1", "beta2","beta3","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "Yp"), 
                    n.chains = 3, n.iter=20000, thin = 15)

# not run b/c takes too long with Yp as outputs
#summary(samp.structure.re)
#plot(samp.structure.re)

#gelman.diag(samp.structure.re)
#acfplot(samp.structure.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.re[[1]]
 saveRDS(samps, "outputs/growth_model/basic_reg_structure_re/samps.rds")
 Yp.samps    <- samps[,1:length(test$site)] 
 alpha.samps <- samps[,(length(test$site)+1):(length(test$site)+2)] # one alpha for each of 16 sites
 beta1.samps  <- samps[,(length(test$site)+3):(length(test$site)+4)]
 beta2.samps <- samps[,(length(test$site)+5):(length(test$site)+6)]
 sigma.samps <- samps[,(length(test$site)+7)]
 sigma_betas <- samps[,(length(test$site)+8):(length(test$site)+10)]
 
 # derived quantities:
 beta1.diffs <- beta1.samps[,1] - beta2.samps[,2]
hist(beta1.diffs)


 # plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value), 0.975),
                                                 ci.lo = quantile(exp(value), 0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/basic_reg_structure_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "basic_reg_structure_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)


 
# plot marginal distributions of each parameter:

png("outputs/growth_model/basic_reg_structure_re/marginal_alphas.png")
par(mfrow=c(1,3))
hist(alpha.samps[,1], main = "alpha Forest")
hist(alpha.samps[,2], main = "alpha Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/basic_reg_structure_re/marginal_beta1s.png")
par(mfrow=c(1,3))
hist(beta1.samps[,1], main = "beta2 Forest")
hist(beta1.samps[,2], main = "beta2 Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()


png("outputs/growth_model/basic_reg_structure_re/marginal_beta1_diff.png")

hist(beta1.diffs, main = "Difference between savanna and forest beta1")
abline(v=0,col="red")
dev.off()

png("outputs/growth_model/basic_reg_structure_re/marginal_beta2s.png")
par(mfrow=c(1,3))
hist(beta2.samps[,1], main = "beta3 Forest")
hist(beta2.samps[,2], main = "beta3 Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c("Forest", "Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+theme_black()+xlab("random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0("beta2-",c("Forest", "Savanna")))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+theme_black()+xlab("Drought slopes")


b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c("Forest", "Savanna")))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+theme_black()+xlab("DBH random slopes")

library(cowplot)
png(width = 4, height = 6, units = "in", res = 300, "outputs/growth_model/basic_reg_structure_re/param_marginal_distn_by_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()


# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 


#AVESD1 <- mean(post_sd1)
#COV1   <- mean(Ytest>post_low1 & Ytest<post_high1)

# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  structure= 1:2)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha.samps[,Xp[j,3]] + beta1.samps[,Xp[j,3]]*Xp[j,1] + beta2.samps[,Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- mu #rnorm(20000, mu, sigma.mn)
  
}

ypred.df <- do.call(rbind, ypred)
y.df <- as.data.frame(ypred.df)
Xp$MeanY <- exp(rowMeans(ypred.df)) # get the means of the posterior to plot the overall effects of 
Xp$structure <- ifelse(Xp$structure == 1, "Forest", "Savanna")
Xp$number <- rownames(Xp)

y.df$number <- 1:length(y.df$V1)
y.df <- merge(Xp, y.df, by = "number")


y.df.m <- melt(y.df, id.vars = c("number", "Var1", "Var2", "structure"))


ggplot(y.df.m, aes(Var1, value, col = structure))+geom_boxplot()

#DBH + DI on predicted growth
png("outputs/growth_model/basic_reg_structure_re/predicted_y.png")
#par(mfrow = c(1,2))
plot(density(ypred.df), main = "Ypred, line = Ydata")
abline(v = mean(Y), col = "red")

#plot(density(d13pred.df), main = "d13pred, line = d13data")
#abline(v= mean(d13$Cor.d13C.suess), col = "red")
dev.off()
# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_structure_re/Ypred_by_drought_structure.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(structure)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")


dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_structure_re/Ypred_by_DBH_structure.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(structure)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_structure_re/Ypred_by_drought_DBH_structure.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(structure))
dev.off()


```



model with site or stand structure by ageclass as the factor to take random effects on:
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_structure_x_cohort_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]   # use Drought index as a scaled variable 

#r1[i] <- Y[i] - gfunc[i]   

}

#RSS[1] <- sum(r1^2)

# Prediction
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] 
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)

#r2[s] <- a[j] - mu_beta1
}
#RSS[2] <- sum(r2^2)


# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)






}"



# should be the same test and training datasets, but save here anyways
saveRDS(train, "outputs//growth_model/basic_reg_struct_x_cohort_re/train.rds")
saveRDS(test, "outputs//growth_model/basic_reg_struct_x_cohort_re/test.rds")

# generate fake data to predict on:
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 Xp <- full.probe
 np <- length(Xp$Var1)


 
 # run the model:
reg.model.by_structure_x_cohort <- jags.model(textConnection(population_model_structure_x_cohort_re), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled), n.chains = 3, n.adapt = 100)

update(reg.model.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.cohort.re <- coda.samples(reg.model.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "Yp"), 
                    n.chains = 3, n.iter=20000, thin = 15)


# check for convergence (not run, but checked)
#summary(samp.structure.cohort.re)
#plot(samp.structure.cohort.re)

#gelman.diag(samp.structure.cohort.re)
#acfplot(samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/basic_reg_struct_x_cohort_re/samps.rds")
  samps <- readRDS("outputs//growth_model/basic_reg_struct_x_cohort_re/samps.rds")
 Yp.samps <- samps[,1:(length(test$RWI))] 
 
 alpha.samps  <- samps[,(length(test$RWI)+ 1):(length(test$RWI)+ 4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+ 5):(length(test$RWI)+ 8)]
 beta3.samps <- samps[,(length(test$RWI)+ 9):(length(test$RWI)+ 12)]
 sigma.samps <- samps[,(length(test$RWI)+ 13)]
 sigma_betas <- samps[,(length(test$RWI)+ 14):(length(test$RWI)+ 16)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/basic_reg_struct_x_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "basic_reg_struct_x_cohort_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)


# get difference between beta2.samps:
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/basic_reg_struct_x_cohort_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/basic_reg_struct_x_cohort_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/basic_reg_struct_x_cohort_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Drought Index slope")

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/basic_reg_struct_x_cohort_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+ xlim(0, 0.15), b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/basic_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

library(cowplot)
png(width = 5, height = 6, units = "in", res = 300, "outputs/growth_model/basic_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()


Yp <- data.frame(Yp.samps)
colnames(Yp) <- c(paste0("YP-",c(unique(full.ghcn$struct.cohort))))
Yp$num <- rownames(Yp)
Yp.m <- melt(Yp, id.vars=c("num"))
Yp.m$DBHindex <- Xp$Var2
Yp.m$DIindex <- Xp$Var1
Yp.m$struct.cohort <- Xp$struct.cohort
ggplot(Yp.m, aes(value, color = as.factor(Yp.m$struct.cohort)))+geom_density(alpha = 0.5)+theme_bw()
library(ggridges)

ggplot(Yp.m, aes(x = value, y = as.factor(DIindex))) + 
  geom_density_ridges()

ggplot(full.ghcn, aes(x = log(RWI), y = as.factor(struct.cohort))) + 
  geom_density_ridges()

# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta2.samps)
 beta2.mn  <- colMeans(beta3.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 


# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 ypred.yp <- list()
 diff <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- rnorm(np, mu, sigma.mn)
  # lines(density(y),col=2)
   #ypred.yp[[j]] <- Yp.samps[,j]
   #diff[[j]] <- ypred[[j]] - Yp.samps[[j]]
   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)
#diff.df <- do.call(rbind, diff)
#ypred.yp.df <- do.call(rbind, ypred.yp)

Xp$MeanY <- exp(rowMeans(ypred.df))
#Xp$MeanYhat <- exp(rowMeans(ypred.yp.df))# get the means of the posterior to plot the overall effects of 
Xp$struct.cohort <- ifelse(Xp$struct.cohort == 1, "Past-Forest",  
                       ifelse(Xp$struct.cohort == 2, "Modern-Forest",
                               ifelse(Xp$struct.cohort == 3, "Past-Savanna", 
                                       ifelse(Xp$struct.cohort == 4, "Modern-Savanna", NA))))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(struct.cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
dev.off()


```



model with re effects @ the structure (forest vs. savanna) level and prev years growth (lag -1):
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_structure_re_lag <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[structure[i]] + beta2[structure[i]]*DI.scaled[i] + beta3[structure[i]]*DBH.scaled[i] +beta4[structure[i]]*log_RWI_1[i]  # use Drought index as a scaled variable 

res[i] <- Y[i] - gfunc[i]   
emp.new[i] ~ dnorm(gfunc[i], sigma)
res.new[i] <- emp.new[i] - gfunc[i]
}



# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
}

# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


for(i in 1:np){
# process model
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1[structure.p[i]] + beta2[structure.p[i]]*DI.scaled.p[i] + beta3[structure.p[i]]*DBH.scaled.p[i] + beta4[structure.p[i]]*log_RWI_1.p[i]  # use Drought index as a scaled variable 

}




}"





# save these for use later:
saveRDS(train, "outputs/growth_model/lag_reg_structure_re/train.rds")
saveRDS(test, "outputs/growth_model/lag_reg_structure_re/test.rds")



# run the JAGS model:
lag.model.by_structure <- jags.model(textConnection(population_model_structure_re_lag), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, structure = as.numeric(train$structure),log_RWI_1 = log(train$RWI_1), SF = unique(train$structure), np=length(test$year), DI.scaled.p = test$DI.scaled, DBH.scaled.p = test$DBH.scaled, structure.p = as.numeric(test$structure), log_RWI_1.p = log(test$RWI_1)), n.chains = 3, n.adapt = 100)

# Burnin for 1000 samples to start, then go higher later
update(lag.model.by_structure, 1000); 

# get samples using coda.samples:
samp.structure.re <- coda.samples(lag.model.by_structure, 
                     variable.names=c("beta1", "beta2","beta3","beta4","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3","sigma_beta4", "Yp"), 
                    n.chains = 3, n.iter=2000, thin = 15)

#summary(samp.structure.re)
#plot(samp.structure.re)

#gelman.diag(samp.structure.re)
#acfplot(samp.structure.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.re[[1]]
 saveRDS(samps, "outputs/growth_model/lag_reg_structure_re/samps.rds")
 Yp.samps    <- samps[,1:length(test$site)] 
 alpha.samps <- samps[,(length(test$site)+1):(length(test$site)+2)] # one alpha for each of 16 sites
 beta1.samps  <- samps[,(length(test$site)+3):(length(test$site)+4)]
 beta2.samps <- samps[,(length(test$site)+5):(length(test$site)+6)]
beta3.samps <- samps[,(length(test$site)+7):(length(test$site)+8)]
 sigma.samps <- samps[,(length(test$site)+9)]
 sigma_betas <- samps[,(length(test$site)+10):(length(test$site)+11)]
 
 # derived quantities:
 beta1.diffs <- beta1.samps[,1] - beta2.samps[,2]
hist(beta1.diffs)


 
# plot marginal distributions of each parameter:

png("outputs/growth_model/lag_reg_structure_re/marginal_alphas.png")
par(mfrow=c(1,3))
hist(alpha.samps[,1], main = "alpha Forest")
hist(alpha.samps[,2], main = "alpha Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag_reg_structure_re/marginal_beta1s.png")
par(mfrow=c(1,3))
hist(beta1.samps[,1], main = "beta2 Forest")
hist(beta1.samps[,2], main = "beta2 Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()


png("outputs/growth_model/lag_reg_structure_re/marginal_beta1_diff.png")

hist(beta1.diffs, main = "Difference between savanna and forest beta1")
abline(v=0,col="red")
dev.off()

png("outputs/growth_model/lag_reg_structure_re/marginal_beta2s.png")
par(mfrow=c(1,3))
hist(beta2.samps[,1], main = "beta3 Forest")
hist(beta2.samps[,2], main = "beta3 Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c("Forest", "Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+theme_black()+xlab("random intercepts")


b2 <- data.frame(beta1.samps)
colnames(b2) <- c(paste0("beta2-",c("Forest", "Savanna")))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+theme_black()+xlab("Drought slopes")


b3 <- data.frame(beta2.samps)
colnames(b3) <- c(paste0("beta3-",c("Forest", "Savanna")))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+theme_black()+xlab("DBH random slopes")

b4 <- data.frame(beta3.samps)
colnames(b4) <- c(paste0("beta4-",c("Forest", "Savanna")))
b4$num <- rownames(b4)
b4.m <- melt(b3, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+theme_black()+xlab("prev_growth random slopes")

library(cowplot)
png(width = 4, height = 6, units = "in", res = 300, "outputs/growth_model/lag_reg_structure_re/param_marginal_distn_by_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()


# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 

 # plot predicted vs. observed & R-sqared:
 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note better model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag_reg_structure_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag_reg_structure_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)




# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  structure= 1:2)

 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 for(j in 1:np){

  
   mu <- alpha.samps[,Xp[j,3]] + beta1.samps[,Xp[j,3]]*Xp[j,1] + beta2.samps[,Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- mu #rnorm(20000, mu, sigma.mn)
  
}

ypred.df <- do.call(rbind, ypred)
y.df <- as.data.frame(ypred.df)
Xp$MeanY <- exp(rowMeans(ypred.df)) # get the means of the posterior to plot the overall effects of 
Xp$structure <- ifelse(Xp$structure == 1, "Forest", "Savanna")
Xp$number <- rownames(Xp)

y.df$number <- 1:length(y.df$V1)
y.df <- merge(Xp, y.df, by = "number")


y.df.m <- melt(y.df, id.vars = c("number", "Var1", "Var2", "structure"))


ggplot(y.df.m, aes(Var1, value, col = structure))+geom_boxplot()

#DBH + DI on predicted growth
png("outputs/growth_model/lag_reg_structure_re/predicted_y.png")
#par(mfrow = c(1,2))
plot(density(ypred.df), main = "Ypred, line = Ydata")
abline(v = mean(Y), col = "red")

#plot(density(d13pred.df), main = "d13pred, line = d13data")
#abline(v= mean(d13$Cor.d13C.suess), col = "red")
dev.off()
# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/lag_reg_structure_re/Ypred_by_drought_structure.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(structure)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")


dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/lag_reg_structure_re/Ypred_by_DBH_structure.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(structure)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/lag_reg_structure_re/Ypred_by_drought_DBH_structure.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(structure))
dev.off()


```
# check above models


model with stand structure by ageclass random effects and prev years growth (lag -1):
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_structure_x_cohort_re_lag <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]+beta4[struct.cohort[i]]*log_RWI_1[i]   # use Drought index as a scaled variable 

#r1[i] <- Y[i] - gfunc[i]   

}

#RSS[1] <- sum(r1^2)

# Prediction
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] +beta4[struct.cohort.p[i]]*log_RWI_1.p[i] 
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
#r2[s] <- a[j] - mu_beta1
}
#RSS[2] <- sum(r2^2)


# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


}"





saveRDS(train, "outputs/growth_model/lag_reg_struct_x_cohort_re/train.rds")
saveRDS(test, "outputs/growth_model/lag_reg_struct_x_cohort_re/test.rds")



lag.model.by_structure_x_cohort <- jags.model(textConnection(population_model_structure_x_cohort_re_lag), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled,log_RWI_1 = log(train$RWI_1), struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled, log_RWI_1.p = log(test$RWI_1)), n.chains = 3, n.adapt = 100)

update(lag.model.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


lag.samp.structure.cohort.re <- coda.samples(lag.model.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","beta4","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4","Yp"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(lag.samp.structure.cohort.re)
#plot(lag.samp.structure.cohort.re)

#gelman.diag(lag.samp.structure.cohort.re)
#acfplot(lag.samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- lag.samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/lag_reg_struct_x_cohort_re/samps.rds")
  samps <- readRDS("outputs//growth_model/lag_reg_struct_x_cohort_re/samps.rds")

 Yp.samps <- samps[,1:(length(test$RWI))] 
 alpha.samps  <- samps[,(length(test$RWI)+ 1):(length(test$RWI)+ 4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+ 5):(length(test$RWI)+ 8)]
 beta3.samps <- samps[,(length(test$RWI)+ 9):(length(test$RWI)+ 12)]
 beta4.samps <- samps[,(length(test$RWI)+ 13):(length(test$RWI)+ 16)]
 sigma.samps <- samps[,(length(test$RWI)+ 17)]
 sigma_betas <- samps[,(length(test$RWI)+ 18):(length(test$RWI)+ 21)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag_reg_struct_x_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag_reg_struct_x_cohort_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)


# get difference between beta2.samps: (i.e are they different?)
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/lag_reg_struct_x_cohort_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag_reg_struct_x_cohort_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/lag_reg_struct_x_cohort_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Drought Index slope")

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag_reg_struct_x_cohort_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+ xlim(0, 0.15), b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/lag_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

library(cowplot)
png(width = 5, height = 8, units = "in", res = 300, "outputs/growth_model/lag_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, ncol = 1)
dev.off()

```

model with stand structure by ageclass random effects and prev years growth (lag -1) and includes site level random intercepts, but cohort/structure random slopes:
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
site_model_structure_x_cohort_re_lag <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[site[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]+beta4[struct.cohort[i]]*log_RWI_1[i]   # use Drought index as a scaled variable 

}

#RSS[1] <- sum(r1^2)

# Prediction
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[site.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] +beta4[struct.cohort.p[i]]*log_RWI_1.p[i] 
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){

beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
#r2[s] <- a[j] - mu_beta1
}
#RSS[2] <- sum(r2^2)

for(p in 1:length(plots)){
beta1[p] ~ dnorm(mu_beta1, inv_beta1)
}

# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


}"





# save these for use later:
saveRDS(train, "outputs/growth_model/lag_site_struct_x_cohort_re/train.rds")
saveRDS(test, "outputs/growth_model/lag_site_struct_x_cohort_re/test.rds")



lag.model.by_structure_x_cohort <- jags.model(textConnection(site_model_structure_x_cohort_re_lag), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled,log_RWI_1 = log(train$RWI_1), struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(ghcn.clean$struct.cohort.code), plots = unique(ghcn.clean$site), site = as.numeric(ghcn.clean$site), np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled, log_RWI_1.p = log(test$RWI_1), site.p = as.numeric(test$site)), n.chains = 3, n.adapt = 100)

update(lag.model.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.cohort.re <- coda.samples(lag.model.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","beta4","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4","Yp"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.cohort.re)
#plot(samp.structure.cohort.re)

#gelman.diag(samp.structure.cohort.re)
#acfplot(samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/lag_site_struct_x_cohort_re/samps.rds")
  samps <- readRDS("outputs//growth_model/lag_site_struct_x_cohort_re/samps.rds")

 Yp.samps <- samps[,1:(length(test$RWI))] 
 alpha.samps  <- samps[,(length(test$RWI)+ 1):(length(test$RWI)+ 16)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+ 17):(length(test$RWI)+ 20)]
 beta3.samps <- samps[,(length(test$RWI)+ 21):(length(test$RWI)+ 24)]
 beta4.samps <- samps[,(length(test$RWI)+ 25):(length(test$RWI)+ 28)]
 sigma.samps <- samps[,(length(test$RWI)+ 29)]
 sigma_betas <- samps[,(length(test$RWI)+ 30):(length(test$RWI)+ 33)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag_site_struct_x_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag_site_struct_x_cohort_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)


# get difference between beta2.samps: (i.e are they different?)
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]

# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/lag_site_struct_x_cohort_re/marginal_alphas.png")
par(mfrow=c(5,4))
for(i in 1:length(unique(ghcn.clean$site))){
hist(alpha.samps[,i], main = paste("random intecept", unique(ghcn.clean$site)[i]))

}
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag_site_struct_x_cohort_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/lag_site_struct_x_cohort_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()

png("outputs/growth_model/lag_site_struct_x_cohort_re/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,4], main = "sigma beta3")
dev.off()

# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-", unique(ghcn.clean$site)))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Drought Index slope")

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975))+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag_site_struct_x_cohort_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+ xlim(0, 0.15), b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/lag_site_struct_x_cohort_re/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH effect")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Lag-1 Effect")


png(width = 5, height = 8, units = "in", res = 300, "outputs/growth_model/lag_site_struct_x_cohort_re/param_marginal_distn_bycohort_struct.png")
cowplot::plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, ncol = 1)
dev.off()

```


#model with stand structure by ageclass random effects and prev years growth (lag -1) and (lag - 2):
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_structure_x_cohort_re_lag2 <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]+beta4[struct.cohort[i]]*log_RWI_1[i]+beta5[struct.cohort[i]]*log_RWI_2[i]   # use Drought index as a scaled variable 

#r1[i] <- Y[i] - gfunc[i]   

}

#RSS[1] <- sum(r1^2)

# Prediction
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] +beta4[struct.cohort.p[i]]*log_RWI_1.p[i] +beta5[struct.cohort.p[i]]*log_RWI_2.p[i] 
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
beta5[s] ~ dnorm(mu_beta5, inv_beta5)

}



# use normalpriors for each  beta paramters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)
mu_beta5 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.01, 0.01)
sigma_beta5 <- 1/sqrt(inv_beta5)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


}"





# save these for use later:
saveRDS(train, "outputs/growth_model/lag2_reg_struct_x_cohort_re/train.rds")
saveRDS(test, "outputs/growth_model/lag2_reg_struct_x_cohort_re/test.rds")



lag2.model.by_structure_x_cohort <- jags.model(textConnection(population_model_structure_x_cohort_re_lag2), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled,log_RWI_1 = log(train$RWI_1),log_RWI_2 = log(train$RWI_2), struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled, log_RWI_1.p = log(test$RWI_1), log_RWI_2.p = log(test$RWI_2)), n.chains = 3, n.adapt = 100)

update(lag2.model.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.cohort.re <- coda.samples(lag2.model.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","beta4","beta5","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4","sigma_beta5","Yp"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.cohort.re)
#plot(samp.structure.cohort.re)

#gelman.diag(samp.structure.cohort.re)
#acfplot(samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/lag2_reg_struct_x_cohort_re/samps.rds")
  samps <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re/samps.rds")

 Yp.samps <- samps[,1:(length(test$RWI))] 
 alpha.samps  <- samps[,(length(test$RWI)+ 1):(length(test$RWI)+ 4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+ 5):(length(test$RWI)+ 8)]
 beta3.samps <- samps[,(length(test$RWI)+ 9):(length(test$RWI)+ 12)]
 beta4.samps <- samps[,(length(test$RWI)+ 13):(length(test$RWI)+ 16)]
 beta5.samps <- samps[,(length(test$RWI)+ 17):(length(test$RWI)+ 20)]
 sigma.samps <- samps[,(length(test$RWI)+ 21)]
 sigma_betas <- samps[,(length(test$RWI)+ 22):(length(test$RWI)+ 26)]

 
 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps)) ~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag2_reg_struct_x_cohort_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)



# get difference between beta2.samps: (i.e are they different?)
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/lag2_reg_struct_x_cohort_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png("outputs/growth_model/lag2_reg_struct_x_cohort_re/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,4], main = "sigma beta4")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta5 Past-Forest")
hist(beta5.samps[,2], main = "beta5 Modern-Forest")
hist(beta5.samps[,3],  main = "beta5 Past-Savanna")
hist(beta5.samps[,4],  main = "beta5 Modern-Savanna")
hist(sigma_betas[,5], main = "sigma beta5")
dev.off()

# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Drought Index slope")

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag2_reg_struct_x_cohort_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+ xlim(0, 0.15), b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(paste0("beta5-",c(unique(train$struct.cohort))))
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

library(cowplot)
png(width = 5, height = 10, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, b5.mplots,ncol = 1)
dev.off()

```
 
 #model with MAP as drought index stand structure by ageclass random effects and prev years growth (lag -1) and (lag - 2):
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_structure_x_cohort_re_lag2_temp_MAP <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] +   beta3[struct.cohort[i]]*DBH.scaled[i]+beta4[struct.cohort[i]]*log_RWI_1[i]+beta5[struct.cohort[i]]*log_RWI_2[i]  + beta6[struct.cohort[i]]*Temp.scaled[i] # use Drought index as a scaled variable 

#r1[i] <- Y[i] - gfunc[i]   

}

#RSS[1] <- sum(r1^2)

# Prediction from known data
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] +beta4[struct.cohort.p[i]]*log_RWI_1.p[i] +beta5[struct.cohort.p[i]]*log_RWI_2.p[i] + beta6[struct.cohort.p[i]]*Temp.scaled.p[i]
  }

# probe for prediction plots:
  for(i in 1:nprobe){
    Yprobe[i]  ~ dnorm(muprobe[i],inv.var)
    muprobe[i] <- beta1[struct.cohort.probe[i]] + beta2[struct.cohort.probe[i]]*DI.scaled.probe[i] + beta3[struct.cohort.probe[i]]*DBH.scaled.probe[i] +beta4[struct.cohort.probe[i]]*log_RWI_1.probe[i] +beta5[struct.cohort.probe[i]]*log_RWI_2.probe[i] + beta6[struct.cohort.probe[i]]*Temp.scaled.probe[i]
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
beta5[s] ~ dnorm(mu_beta5, inv_beta5)
beta6[s] ~ dnorm(mu_beta5, inv_beta6)
}



# use normalpriors for each  beta paramters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)
mu_beta5 ~ dunif(-2, 2)
mu_beta6 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.01, 0.01)
sigma_beta5 <- 1/sqrt(inv_beta5)
inv_beta6   ~ dgamma(0.01, 0.01)
sigma_beta6 <- 1/sqrt(inv_beta6)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


}"





# save these for use later:
saveRDS(train, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/train.rds")
saveRDS(test, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/test.rds")
train <- readRDS("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/train.rds")
test <- readRDS("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/test.rds")



# generate probe dataset:
 DIprobe <- round(seq(range(train$MAP.scaled)[1], range(train$MAP.scaled)[2], by = 0.75), 3)
 DBHprobe <- round(seq(range(train$DBH.scaled)[1], range(train$DBH.scaled)[2], by = 0.75), 3)
 Tempprobe <- round(seq(range(train$T.scaled)[1], range(train$T.scaled)[2], by = 0.75), 3)
 RWI1probe <- round(seq(range(log(train$RWI_1))[1], range(log(train$RWI_1))[2], by = 0.5), 3)
 RWI2probe <- round(seq(range(log(train$RWI_2))[1], range(log(train$RWI_2))[2], by = 0.5), 3)
 
 # expand into full probe
probe <- expand.grid(DI.scaled = DIprobe, DBH.scaled = DBHprobe, T.scaled = Tempprobe,
                         RWI_1 = RWI1probe, RWI_2= RWI2probe ,struct.cohort.code= 1:4)



lag2.model.by_structure_x_cohort_t_pr <- jags.model(textConnection(population_model_structure_x_cohort_re_lag2_temp_MAP), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled,log_RWI_1 = log(train$RWI_1),log_RWI_2 = log(train$RWI_2), Temp.scaled = train$T.scaled, struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled, log_RWI_1.p = log(test$RWI_1), log_RWI_2.p = log(test$RWI_2), Temp.scaled.p = test$T.scaled, nprobe = length(probe$DBH.scaled),
   struct.cohort.probe = as.numeric(probe$struct.cohort.code), DBH.scaled.probe = probe$DBH.scaled, DI.scaled.probe = probe$DI.scaled, log_RWI_1.probe = probe$RWI_1, log_RWI_2.probe = probe$RWI_2, Temp.scaled.probe = probe$T.scaled), n.chains = 3, n.adapt = 100)

update(lag2.model.by_structure_x_cohort_t_pr, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.cohort.re <- coda.samples(lag2.model.by_structure_x_cohort_t_pr, 
                     variable.names=c("beta1", "beta2","beta3","beta4","beta5","beta6","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4","sigma_beta5", "sigma_beta6","Yp", "Yprobe"), 
                    n.chains = 3, n.iter=1000, thin = 15)

#summary(samp.structure.cohort.re)
#plot(samp.structure.cohort.re)

#gelman.diag(samp.structure.cohort.re)
#acfplot(samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr/samps.rds")
  samps <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr/samps.rds")
test <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr/test.rds")
train <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr/train.rds")

 Yp.samps <- samps[,1:(length(test$RWI))] 
Yprobe.samps <- samps[,(length(test$RWI)+1):(length(probe$DI.scaled))] 
 alpha.samps  <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+1):(length(test$RWI)+(length(probe$DI.scaled))+ 4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+5):(length(test$RWI)+ (length(probe$DI.scaled))+8)]
 beta3.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+9):(length(test$RWI)+ (length(probe$DI.scaled))+12)]
 beta4.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+13):(length(test$RWI)+(length(probe$DI.scaled))+ 16)]
 beta5.samps <- samps[,(length(test$RWI)+(length(probe$DI.scaled))+ 17):(length(test$RWI)+(length(probe$DI.scaled))+ 20)]
 beta6.samps <- samps[,(length(test$RWI)+(length(probe$DI.scaled))+ 21):(length(test$RWI)+(length(probe$DI.scaled))+ 24)]
 sigma.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+25)]
 sigma_betas <- samps[,(length(test$RWI)+(length(probe$DI.scaled))+ 26):(length(test$RWI)+(length(probe$DI.scaled))+ 31)]

 
 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps)) ~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note best model fit so far
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag2_reg_struct_x_cohort_re_t_pr", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)



# get difference between beta2.samps: (i.e are they different?)
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,4], main = "sigma beta4")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_beta4s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta5 Past-Forest")
hist(beta5.samps[,2], main = "beta5 Modern-Forest")
hist(beta5.samps[,3],  main = "beta5 Past-Savanna")
hist(beta5.samps[,4],  main = "beta5 Modern-Savanna")
hist(sigma_betas[,5], main = "sigma beta5")
dev.off()


png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_beta5s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta4 Past-Forest")
hist(beta5.samps[,2], main = "beta4 Modern-Forest")
hist(beta5.samps[,3],  main = "beta4 Past-Savanna")
hist(beta5.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,6], main = "sigma beta4")
dev.off()

# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Precipitation Index slope")

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0(c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH Index slope")


b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0(c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Log_RWI-1 Index slope")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(paste0(c(unique(train$struct.cohort))))
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Log_RWI-2 Index slope")

b6 <- data.frame(beta6.samps)
colnames(b6) <- c(paste0(c(unique(train$struct.cohort))))
b6$num <- rownames(b6)
b6.m <- melt(b6, id.vars=c("num"))
b6.mplots <- ggplot(b6.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Summer Temperature slope")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/drougt_beta_marginal_distn_bycohort.png")
cowplot::plot_grid(alpha.mplots, b2.mplots, b3.mplots, b4.mplots, b5.mplots, b6.mplots)
dev.off()

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+ xlim(0, 0.15), b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(paste0("beta5-",c(unique(train$struct.cohort))))
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

library(cowplot)
png(width = 5, height = 10, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/param_marginal_distn_bycohort_struct_1.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, b5.mplots,ncol = 1)
dev.off()

# --------------------make plots of probed predicted growth responses:
# plot probed values of tree growth predictions:
Yprobe <- data.frame(Yprobe.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
probe.m$RWI <- exp(probe.m$value) 
colnames(probe.m) <- c("num", "Ypred", "RWI")

probe$num <- 1:length(probe[,1])
colnames(probe) <- c("Drought", "DBH","Tmax", "RWI_1","RWI_2","struct.cohort", "num")

# summarize by structure + cohort class only:
# summarize by structure + cohort class only:
probe$num <- as.factor(as.character(probe$num))
full.p <- probe

probtest <- dplyr::inner_join(probe.m, full.p, by=c("num"))

prob <- probtest
# save here:
saveRDS(prob, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/full_yprobe_preds.rds")
prob <- readRDS("outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/full_yprobe_preds.rds")




preds_ci_mod_past$ageclass <- factor(preds_ci_mod_past$ageclass, levels = c("Past", "Modern"))
gg.tile.past.mod <- ggplot(preds_ci_mod_past, aes(PDSI, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~ageclass, ncol = 1)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("Palmer Drought Severity Index")+theme_bw(base_size = 12)


png(height = 4, width = 3, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re/predicted_growth_mod_past_tile.png")
gg.tile.past.mod
dev.off()




```
 
  #FOR DRY YEARS ONLY: model with MAP as drought index stand structure by ageclass random effects and prev years growth (lag -1) and (lag - 2):
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"

# save these for use later:
saveRDS(train.dry, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/train.rds")
saveRDS(test.dry, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/test.rds")
train.dry <- readRDS("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/train.rds")
test.dry <- readRDS("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/test.rds")



# generate probe dataset:
 DIprobe <- round(seq(range(train.dry$MAP.scaled)[1], range(train.dry$MAP.scaled)[2], by = 0.75), 3)
 DBHprobe <- round(seq(range(train.dry$DBH.scaled)[1], range(train.dry$DBH.scaled)[2], by = 0.75), 3)
 Tempprobe <- round(seq(range(train.dry$T.scaled)[1], range(train.dry$T.scaled)[2], by = 0.75), 3)
 RWI1probe <- round(seq(range(log(train.dry$RWI_1))[1], range(log(train.dry$RWI_1))[2], by = 0.5), 3)
 RWI2probe <- round(seq(range(log(train.dry$RWI_2))[1], range(log(train.dry$RWI_2))[2], by = 0.5), 3)
 
 # expand into full probe
probe <- expand.grid(DI.scaled = DIprobe, DBH.scaled = DBHprobe, T.scaled = Tempprobe,
                         RWI_1 = RWI1probe, RWI_2= RWI2probe, struct.cohort.code= 1:4)



lag2.model.by_structure_x_cohort_t_pr <- jags.model(textConnection(population_model_structure_x_cohort_re_lag2_temp_MAP), 
                    data = list(Y=log(train.dry$RWI), n=length(train.dry$RWI), DI.scaled = train.dry$DI.scaled, DBH.scaled = train.dry$DBH.scaled,log_RWI_1 = log(train.dry$RWI_1),log_RWI_2 = log(train.dry$RWI_2), Temp.scaled = train.dry$T.scaled, struct.cohort = as.numeric(train.dry$struct.cohort.code), SF = unique(train.dry$struct.cohort.code), np = length(test.dry$DBH.scaled),
   struct.cohort.p = as.numeric(test.dry$struct.cohort.code), DBH.scaled.p = test.dry$DBH.scaled, DI.scaled.p = test.dry$DI.scaled, log_RWI_1.p = log(test.dry$RWI_1), log_RWI_2.p = log(test.dry$RWI_2), Temp.scaled.p = test.dry$T.scaled, nprobe = length(probe$DBH.scaled),
   struct.cohort.probe = as.numeric(probe$struct.cohort.code), DBH.scaled.probe = probe$DBH.scaled, DI.scaled.probe = probe$DI.scaled, log_RWI_1.probe = probe$RWI_1, log_RWI_2.probe = probe$RWI_2, Temp.scaled.probe = probe$T.scaled), n.chains = 3, n.adapt = 100)

update(lag2.model.by_structure_x_cohort_t_pr, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.cohort.re <- coda.samples(lag2.model.by_structure_x_cohort_t_pr, 
                     variable.names=c("beta1", "beta2","beta3","beta4","beta5","beta6","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4","sigma_beta5", "sigma_beta6","Yp", "Yprobe"), 
                    n.chains = 3, n.iter=5000, thin = 15)

#summary(samp.structure.cohort.re)
#plot(samp.structure.cohort.re)

#gelman.diag(samp.structure.cohort.re)
#acfplot(samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/samps.rds")
  samps <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/samps.rds")
test.dry <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/test.rds")
train.dry <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/train.rds")

 Yp.samps <- samps[,1:(length(test.dry$RWI))] 
 Yprobe.samps <- samps[,(length(test.dry$RWI)+1):(length(probe$DI.scaled))] 
 alpha.samps  <- samps[,(length(test.dry$RWI)+ (length(probe$DI.scaled))+1):(length(test.dry$RWI)+(length(probe$DI.scaled))+ 4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test.dry$RWI)+ (length(probe$DI.scaled))+5):(length(test.dry$RWI)+ (length(probe$DI.scaled))+8)]
 beta3.samps <- samps[,(length(test.dry$RWI)+ (length(probe$DI.scaled))+9):(length(test.dry$RWI)+ (length(probe$DI.scaled))+12)]
 beta4.samps <- samps[,(length(test.dry$RWI)+ (length(probe$DI.scaled))+13):(length(test.dry$RWI)+(length(probe$DI.scaled))+ 16)]
 beta5.samps <- samps[,(length(test.dry$RWI)+(length(probe$DI.scaled))+ 17):(length(test.dry$RWI)+(length(probe$DI.scaled))+ 20)]
 beta6.samps <- samps[,(length(test.dry$RWI)+(length(probe$DI.scaled))+ 21):(length(test.dry$RWI)+(length(probe$DI.scaled))+ 24)]
 sigma.samps <- samps[,(length(test.dry$RWI)+ (length(probe$DI.scaled))+25)]
 sigma_betas <- samps[,(length(test.dry$RWI)+(length(probe$DI.scaled))+ 26):(length(test.dry$RWI)+(length(probe$DI.scaled))+ 31)]

 
 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test.dry$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps)) ~ test.dry$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)+theme_bw()

# note best model fit so far
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test.dry$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test.dry$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag2_reg_struct_x_cohort_re_t_pr_dry_yrs", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)



# get difference between beta2.samps: (i.e are they different?)
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]

# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,4], main = "sigma beta4")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_beta4s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta5 Past-Forest")
hist(beta5.samps[,2], main = "beta5 Modern-Forest")
hist(beta5.samps[,3],  main = "beta5 Past-Savanna")
hist(beta5.samps[,4],  main = "beta5 Modern-Savanna")
hist(sigma_betas[,5], main = "sigma beta5")
dev.off()


png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_beta5s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta4 Past-Forest")
hist(beta5.samps[,2], main = "beta4 Modern-Forest")
hist(beta5.samps[,3],  main = "beta4 Past-Savanna")
hist(beta5.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,6], main = "sigma beta4")
dev.off()

# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <-c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
#colnames(b2) <- c(paste0(c(unique(train.dry$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Precipitation Index slope")

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH Index slope")


b4 <- data.frame(beta4.samps)
colnames(b4) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Log_RWI-1 Index slope")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Log_RWI-2 Index slope")

b6 <- data.frame(beta6.samps)
colnames(b6) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
b6$num <- rownames(b6)
b6.m <- melt(b6, id.vars=c("num"))
b6.mplots <- ggplot(b6.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Summer Temperature slope")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/drougt_beta_marginal_distn_bycohort.png")
cowplot::plot_grid(alpha.mplots, b2.mplots, b3.mplots, b4.mplots, b5.mplots, b6.mplots)
dev.off()

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))


b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(-0.1, 0.25)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

# ------------------------- DOTPLOT MODEL SUMMARIES -----------------------
# make dotplots for all the factors in the model--
# get summaries by struct-cohort class from the melted samples:

a1.sum <- a.m %>% group_by(variable) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
a1.sum$variable <- factor(a1.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

b2.sum <- b2.m %>% group_by(variable) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
b2.sum$variable <- factor(b2.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))


b3.sum <- b3.m %>% group_by(variable) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
b3.sum$variable <- factor(b3.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))


b4.sum <- b4.m %>% group_by(variable) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
b4.sum$variable <- factor(b4.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

b5.sum <- b5.m %>% group_by(variable) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
b5.sum$variable <- factor(b5.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

b6.sum <- b6.m %>% group_by(variable) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
b6.sum$variable <- factor(b6.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

# write out all the dotplots
int.dot <- ggplot(data.frame(a1.sum), aes(x = mean.val, y = variable, color = variable, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+xlim(-0.1, 0.25)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated Intercept (alpha)")+xlim(-0.3, 0.8) + geom_vline(xintercept = 0, linetype = "dashed")

b2.dot <- ggplot(data.frame(b2.sum), aes(x = mean.val, y = variable, color = variable, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+xlim(-0.1, 0.25)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated Drought Sensitivity (Beta2)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

b3.dot <- ggplot(data.frame(b3.sum), aes(x = mean.val, y = variable, color = variable, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+xlim(-0.1, 0.25)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated DBH Sensitivity (Beta3)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

b4.dot <- ggplot(data.frame(b4.sum), aes(x = mean.val, y = variable, color = variable, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated lag -1 growth coef. (Beta4)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

b5.dot <- ggplot(data.frame(b5.sum), aes(x = mean.val, y = variable, color = variable, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+theme(legend.position = "none", axis.title.y= element_blank())+xlab("Estimated lag -1 growth coef. (Beta5)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")


b6.dot <- ggplot(data.frame(b6.sum), aes(x = mean.val, y = variable, color = variable, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated Max. Temp. sensitivity (Beta6)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

png(height = 12, width = 5, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/full_dot_plot_cohort_struct.png")
plot_grid(int.dot, b2.dot, b6.dot, b3.dot, b4.dot, b5.dot, ncol = 1)
dev.off()

# -------------------- DOTPLOTS by modern vs. past only ---------------------
# make dotplots for all the factors in the model--
# get summaries by struct-cohort class from the melted samples:
a.m$cohort <- ifelse(a.m$variable %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
a1.sum.age <- a.m %>% group_by(cohort) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
#a1.sum.age$variable <- factor(a1.sum.age$coohort, levels = c( "Past", "Modern"))

b2.m$cohort <- ifelse(b2.m$variable %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
b2.sum.age <- b2.m %>% group_by(cohort) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
#b2.sum$variable <- factor(b2.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

b3.m$cohort <- ifelse(b3.m$variable %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")

b3.sum.age <- b3.m %>% group_by(cohort) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
#b3.sum$variable <- factor(b3.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

b4.m$cohort <- ifelse(b4.m$variable %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")

b4.sum.age <- b4.m %>% group_by(cohort) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
#b4.sum$variable <- factor(b4.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

b5.m$cohort <- ifelse(b5.m$variable %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")

b5.sum.age <- b5.m %>% group_by(cohort) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
#b5.sum$variable <- factor(b5.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b6.m$cohort <- ifelse(b6.m$variable %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")

b6.sum.age <- b6.m %>% group_by(cohort) %>% dplyr::summarise(mean.val = mean(value),
                                                   Ci.low = quantile(value, 0.025), 
                                                   Ci.high = quantile(value, 0.975))
#b6.sum$variable <- factor(b6.sum$variable, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

# write out all the dotplots
int.dot.age <- ggplot(data.frame(a1.sum.age), aes(x = mean.val, y = cohort, color = cohort, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+xlim(-0.1, 0.25)+scale_color_manual(values = c("Past"='#2166ac', 'Modern' = "#b2182b"))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated Intercept (alpha)")+xlim(-0.3, 0.8) + geom_vline(xintercept = 0, linetype = "dashed")

b2.dot.age <- ggplot(data.frame(b2.sum.age), aes(x = mean.val, y = cohort, color = cohort, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+xlim(-0.1, 0.25)+scale_color_manual(values = c("Past"='#2166ac', 'Modern' = "#b2182b"))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated Drought Sensitivity (Beta2)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

b3.dot.age <- ggplot(data.frame(b3.sum.age), aes(x = mean.val, y = cohort, color = cohort, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+xlim(-0.1, 0.25)+scale_color_manual(values = c("Past"='#2166ac', 'Modern' = "#b2182b"))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated DBH Sensitivity (Beta3)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

b4.dot.age <- ggplot(data.frame(b4.sum.age), aes(x = mean.val, y = cohort, color = cohort, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+scale_color_manual(values = c("Past"='#2166ac', 'Modern' = "#b2182b"))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated lag -1 growth coef. (Beta4)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

b5.dot.age <- ggplot(data.frame(b5.sum.age), aes(x = mean.val, y = cohort, color = cohort, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+scale_color_manual(values = c("Past"='#2166ac', 'Modern' = "#b2182b"))+theme(legend.position = "none", axis.title.y= element_blank())+xlab("Estimated lag -1 growth coef. (Beta5)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")


b6.dot.age <- ggplot(data.frame(b6.sum.age), aes(x = mean.val, y = cohort, color = cohort, size = 2))+geom_errorbarh( aes(xmin = Ci.low, xmax = Ci.high, size = 1,height = 0))+geom_point()+scale_color_manual(values = c("Past"='#2166ac', 'Modern' = "#b2182b"))+theme(legend.position = "none", axis.title.y = element_blank())+xlab("Estimated Max. Temp. sensitivity (Beta6)")+xlim(-0.3, 0.8)+ geom_vline(xintercept = 0, linetype = "dashed")

png(height = 12, width = 5, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/full_dot_plot_cohort_only.png")
plot_grid(int.dot.age, b2.dot.age, b6.dot.age, b3.dot.age, b4.dot.age, b5.dot.age, ncol = 1)
dev.off()


png(height = 12, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/full_dot_plot_cohort_only.png")
plot_grid(int.dot.age, b2.dot.age, b6.dot.age, b3.dot.age, b4.dot.age, b5.dot.age, ncol = 1)
dev.off()


png(height = 12, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/full_dot_plot_cohort_and_cohortXstruct.png")
plot_grid(int.dot.age,int.dot,
         b2.dot.age , b2.dot, 
         b6.dot.age, b6.dot,
         b3.dot.age, b3.dot,
         b4.dot.age,  b4.dot,
         b5.dot.age, b5.dot, ncol = 2, align = "hv", labels = c("a","g",
                                                                "b","h",
                                                                "c","i",
                                                                "d","j",
                                                                "e","k",
                                                                "f","l"), label_x = 0.4)
dev.off()
#---------------------- More beta summary plots -----------------------------
png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots, b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(-0.1, 0.25)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(unique(train.dry$struct.cohort)[order(unique(train.dry[,c("struct.cohort", "struct.cohort.code")])[,2])])
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

library(cowplot)
png(width = 5, height = 10, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/param_marginal_distn_bycohort_struct_1.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, b5.mplots,ncol = 1)
dev.off()

# --------------------make plots of probed predicted growth responses:
# plot probed values of tree growth predictions:
Yprobe <- data.frame(Yprobe.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
probe.m$RWI <- exp(probe.m$value) 
colnames(probe.m) <- c("num", "Ypred", "RWI")

probe$num <- 1:length(probe[,1])
colnames(probe) <- c("Drought", "DBH","Tmax", "RWI_1","RWI_2","struct.cohort", "num")

# summarize by structure + cohort class only:
# summarize by structure + cohort class only:
probe$num <- as.factor(as.character(probe$num))
full.p <- probe

probtest.dry <- dplyr::inner_join(probe.m, full.p, by=c("num"))

prob <- probtest.dry
# save here:
saveRDS(prob, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/full_yprobe_preds.rds")
prob <- readRDS("outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/full_yprobe_preds.rds")




# convert prob$Drought back to MAP:
library(DMwR)
DIprobe <- round(seq(range(train$MAP.scaled)[1], range(train$MAP.scaled)[2], by = 0.75), 3)



prob$DBH <- as.numeric(round(unscale(vals = prob$DBH, norm.data = DBH.scaled))) 
prob$MAP <- as.numeric(round(unscale(vals = prob$Drought, norm.data = MAP.scaled)))
prob$Tmax <- as.numeric(round(unscale(vals = prob$Tmax, norm.data = T.scaled))) 


prob_10_60cm_avg <- prob %>% dplyr::filter(DBH == 3 | DBH == 27 | DBH == 63 , Tmax == 72 | Tmax == 89, RWI_1 == 0.285, RWI_2 == 0.103 ) 

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
 struc.conversion$ageclass <- ifelse(struc.conversion$cohort %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
 prob_10_60cm_avg <- merge(prob_10_60cm_avg,struc.conversion, by  = "struct.cohort")
 
 
preds_ci_10 <- prob_10_60cm_avg %>% group_by(DBH, Drought, Tmax, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

preds_ci_10_age <- prob_10_60cm_avg %>% group_by(DBH, Drought, Tmax, ageclass) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

# same thing but with LOWER than average tree growth the years before:

prob_10_60cm_low <- prob %>% dplyr::filter(DBH == 3 | DBH == 27 | DBH == 63 , Tmax == 72 | Tmax == 89, RWI_1 == -1.215, RWI_2 == -1.397  ) 

 
 prob_10_60cm_low <- merge(prob_10_60cm_low, struc.conversion, by  = "struct.cohort")
 
 
preds_ci_10_low <- prob_10_60cm_low %>% group_by(DBH, Drought, Tmax, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))


preds_ci_10_low_age <- prob_10_60cm_low %>% group_by(DBH, Drought, Tmax, ageclass) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

# same thing but with HIGHER than average tree growth the years before:

prob_10_60cm_high <- prob %>% dplyr::filter(DBH == 3 | DBH == 27 | DBH == 63 , Tmax == 72 | Tmax == 89, RWI_1 == 1.785, RWI_2 == 1.603  ) 


 prob_10_60cm_high <- merge(prob_10_60cm_high, struc.conversion, by  = "struct.cohort")
 
 
preds_ci_10_high <- prob_10_60cm_high %>% group_by(DBH, Drought, Tmax, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

preds_ci_10_high_age <- prob_10_60cm_high %>% group_by(DBH, Drought, Tmax, ageclass) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

#----------- plot drought response by max temperature and Dimaeter + cohort-struct class -----------

Drought.resp.DBH.temp.avgpyr <- ggplot(preds_ci_10, aes(Drought, meanY, color = cohort))+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, linetype = "dashed", colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))+facet_grid(vars(DBH), vars(Tmax),labeller=label_both)+ylab("Tree growth (mm)")+xlab("Precipitation index")+theme_bw()



Drought.resp.DBH.temp.lowpyr <- ggplot(preds_ci_10_low, aes(Drought, meanY, color = cohort))+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, linetype = "dashed", colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))+facet_grid(vars(DBH), vars(Tmax),labeller=label_both)+xlab("Precipitation index")+theme_bw()


Drought.resp.DBH.temp.highpyr <- ggplot(preds_ci_10_high, aes(Drought, meanY, color = cohort))+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, linetype = "dashed", colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))+facet_grid(vars(DBH), vars(Tmax),labeller=label_both)+xlab("Precipitation index")+theme_bw()


# output the above plots to PNG:
png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/MAP_response_low_prevyr_high_temp_low_high_DBH.png")
Drought.resp.DBH.temp.lowpyr 
dev.off()

png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/MAP_response_avg_prevyr_high_temp_low_high_DBH.png")
Drought.resp.DBH.temp.avgpyr 
dev.off()

png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/MAP_response_high_prevyr_high_temp_low_high_DBH.png")
Drought.resp.DBH.temp.highpyr 
dev.off()


#----------- plot drought response by max temperature and Dimaeter + AGECLASS -----------

Drought.resp.DBH.temp.avgpyr.age <- ggplot(preds_ci_10_age, aes(Drought, meanY, color = ageclass))+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+facet_grid(vars(DBH), vars(Tmax),labeller=label_both)+ylab("Predicted Tree growth (mm)")+xlab("Precipitation index")+theme_bw()




Drought.resp.DBH.temp.lowpyr.age <- ggplot(preds_ci_10_low_age, aes(Drought, meanY, color = ageclass))+geom_line()+geom_ribbon(data = preds_ci_10_low_age,aes(ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+facet_grid(vars(DBH), vars(Tmax),labeller=label_both)+ylab("Predicted Tree growth (mm)")+xlab("Precipitation index")+theme_bw()


Drought.resp.DBH.temp.highpyr.age <- ggplot(preds_ci_10_high_age, aes(Drought, meanY, color = ageclass))+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+facet_grid(vars(DBH), vars(Tmax),labeller=label_both)+ylab("Predicted Tree growth (mm)")+xlab("Precipitation index")+theme_bw()


# output the above plots to PNG:
png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/MAP_response_low_prevyr_high_temp_low_high_DBH_ageclass.png")
Drought.resp.DBH.temp.lowpyr.age 
dev.off()

png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/MAP_response_avg_prevyr_high_temp_low_high_DBH_ageclass.png")
Drought.resp.DBH.temp.avgpyr.age+theme_bw(base_size = 14)
dev.off()

png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/MAP_response_high_prevyr_high_temp_low_high_DBH_ageclass.png")
Drought.resp.DBH.temp.highpyr.age 
dev.off()





#--------------- plot marginal effects of climate and previous years growth ----------------

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
 struc.conversion$ageclass <- ifelse(struc.conversion$cohort %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")

 prob <- left_join(prob, struc.conversion, by  = "struct.cohort")

 # Marginal MAP effect:
preds_ci_mod_past_MAP <- prob %>% group_by( MAP, ageclass) %>% summarise(meanY = mean(RWI),                                                                           Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_MAP_marg <- ggplot(preds_ci_mod_past_MAP, aes(MAP,meanY, color = ageclass)) + geom_line()+#geom_smooth(data = preds_ci_mod_past_MAP, aes(x = MAP, y = meanY, se = FALSE)) + 
  geom_ribbon(data = preds_ci_mod_past_MAP,aes(x = MAP, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+ scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Tree growth (mm)")+xlab("Total Annual Precipitation (mm)")+ylim(0, 10)+theme_bw()


# marginal TMAX effect
preds_ci_mod_past_Tmax <- prob %>% group_by( Tmax,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_Tmax_marg <- ggplot(preds_ci_mod_past_Tmax, aes(Tmax, meanY, color = ageclass))+geom_line()+geom_ribbon(data = preds_ci_mod_past_Tmax, aes(x = Tmax, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Tree growth (mm)")+xlab("Max. Temp. (DegF)")+ylim(0,10)+theme_bw()

# marginal DBH effect
preds_ci_mod_past_DBH <- prob %>% group_by( DBH,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_DBH_marg <- ggplot(preds_ci_mod_past_DBH, aes(DBH, meanY, color = ageclass))+geom_line()+geom_ribbon(data = preds_ci_mod_past_DBH, aes(x = DBH, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Tree growth (mm)") + xlab("Tree DBH (cm)")+ylim(0,10)+theme_bw()

# marginal lag-1 effect
preds_ci_mod_past_RWI1 <- prob %>% group_by( RWI_1,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_1_marg <- ggplot(preds_ci_mod_past_RWI1, aes(RWI_1, meanY, color = ageclass))+geom_line()+geom_ribbon(data = preds_ci_mod_past_RWI1, aes(x = RWI_1, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Tree growth (mm)")+xlab("log(Previous (-1) Year's growth)")+ylim(0, 10)+theme_bw()

# marginal lag-2 effect
preds_ci_mod_past_RWI2 <- prob %>% group_by( RWI_2,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_2_marg <- ggplot(preds_ci_mod_past_RWI2, aes(RWI_2,meanY, color = ageclass))+geom_line()+geom_ribbon(data = preds_ci_mod_past_RWI2, aes(x = RWI_2, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Tree growth (mm)")+xlab("log(Previous (-2) Year's growth)")+ylim(0, 10)+theme_bw()


legend <- get_legend(Y_MAP_marg)

png(height = 10, width = 4, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_post_predictive_effects_ageclass.png")
plts <- plot_grid(Y_MAP_marg+theme(legend.position = "none"), Y_Tmax_marg+theme(legend.position = "none"), Y_DBH_marg+theme(legend.position = "none"), Y_RWI_1_marg+theme(legend.position = "none"), Y_RWI_2_marg+theme(legend.position = "none"), align = "v", ncol = 1)
plot_grid(plts, legend, ncol = 2, rel_widths = c(1, 0.35))
dev.off()

# --------------plot marginal effects for each stand structure and cohort class:
# plot marginal effects of climate and previous years growth 
# Marginal MAP effect:
preds_ci_mod_past_MAP <- prob %>% group_by( MAP, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_MAP_marg_c <- ggplot(preds_ci_mod_past_MAP, aes(MAP,meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_MAP, aes(x = MAP, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+ ylab("Tree growth")+ylim(0, 10)+xlab("Total Precipitation")


# marginal TMAX effect
preds_ci_mod_past_Tmax <- prob %>% group_by( Tmax, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_Tmax_marg_c <- ggplot(preds_ci_mod_past_Tmax, aes(Tmax,meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_Tmax, aes(x = Tmax, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+ ylab("Tree growth")+ylim(0, 10)+xlab("Max. Temperature (DegF)")

# marginal DBH effect
preds_ci_mod_past_DBH <- prob %>% group_by( DBH, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_DBH_marg_c <- ggplot(preds_ci_mod_past_DBH, aes(DBH, meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_DBH, aes(x = DBH, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+ ylab("Tree growth")+ylim(0, 10)+xlab("Tree DBH (cm)")

# marginal lag-1 effect
preds_ci_mod_past_RWI1 <- prob %>% group_by( RWI_1, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_1_marg_c <- ggplot(preds_ci_mod_past_RWI1, aes(RWI_1, meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_RWI1, aes(x = RWI_1, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+ ylab("Tree growth")+ylim(0, 10)+xlab("log(Prev (-1) year's growth)")

# marginal lag-2 effect
preds_ci_mod_past_RWI2 <- prob %>% group_by( RWI_2, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_2_marg_c <- ggplot(preds_ci_mod_past_RWI2, aes(RWI_2, meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_RWI2, aes(x = RWI_2, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+ ylab("Tree growth")+ylim(0, 10)+xlab("log(Prev (-2) year's growth)")

png(height = 10, width = 5, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr_dry_yrs/marginal_post_predictive_effects_ageclassXStruct.png")
legend <- get_legend(Y_MAP_marg_c)
plts <- plot_grid(Y_MAP_marg_c+theme(legend.position = "none"), Y_Tmax_marg_c+theme(legend.position = "none"), Y_DBH_marg_c+theme(legend.position = "none"), Y_RWI_1_marg_c+theme(legend.position = "none"), Y_RWI_2_marg_c+theme(legend.position = "none"), align = "v", ncol = 1)
plot_grid(plts, legend, ncol = 2, rel_widths = c(1, 0.45))
dev.off()



# below is some extra code

# -------plot point estimates of growth based on low moisutre under hot and cold conditions by DBH, colored by cohort x stand, and with facets by previous years growth:

prob_lowMAP <- prob %>% dplyr::filter(MAP == 223 , Tmax == 71 | Tmax == 89 , RWI_1 == -1.215 | RWI_1 == 0.285 | RWI_1 == 1.785 , RWI_2 == -1.397 | RWI_2 == 0.103 | RWI_2 == 1.603 ) 

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
prob_lowMAP <- merge(prob_lowMAP,struc.conversion, by  = "struct.cohort")
 
 
prob_lowMAP_ci <- prob_lowMAP %>% group_by(DBH,  Tmax, RWI_1, RWI_2, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

ggplot(prob_lowMAP_ci[prob_lowMAP_ci$Tmax == 89,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)

#ggplot(prob_lowMAP_ci[prob_lowMAP_ci$Tmax == 88,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)

# same but for high MAP
prob_highMAP <- prob %>% dplyr::filter(MAP == 970 , Tmax == 71 | Tmax == 88 , RWI_1 == -1.215 | RWI_1 == 0.285 | RWI_1 == 1.785 , RWI_2 == -1.397 | RWI_2 == 0.103 | RWI_2 == 1.603) 

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
prob_highMAP <- merge(prob_highMAP,struc.conversion, by  = "struct.cohort")
 
 
prob_highMAP_ci <- prob_highMAP %>% group_by(DBH,  Tmax, RWI_1, RWI_2, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

ggplot(prob_highMAP_ci[prob_highMAP_ci$Tmax == 71,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)+theme_bw()

ggplot(prob_highMAP_ci[prob_highMAP_ci$Tmax == 88,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)+theme_bw()

#ggplot(prob_highMAP_ci[prob_highMAP_ci$RWI_2 == -1.397 & prob_highMAP_ci$RWI_1 == -1.466,], aes(DBH, Tmax,fill = meanY))+geom_tile()+facet_grid(~cohort) 



```
 
#model with temperature, precipitation, stand structure by ageclass random effects and prev years growth (lag -1) and (lag - 2):
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
population_model_structure_x_cohort_re_lag2_temp <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] +   beta3[struct.cohort[i]]*DBH.scaled[i]+beta4[struct.cohort[i]]*log_RWI_1[i]+beta5[struct.cohort[i]]*log_RWI_2[i]  + beta6[struct.cohort[i]]*Temp.scaled[i] # use Drought index as a scaled variable 

#r1[i] <- Y[i] - gfunc[i]   

}

#RSS[1] <- sum(r1^2)

# Prediction from known data
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] +beta4[struct.cohort.p[i]]*log_RWI_1.p[i] +beta5[struct.cohort.p[i]]*log_RWI_2.p[i] + beta6[struct.cohort.p[i]]*Temp.scaled.p[i]
  }

# probe for prediction plots:
  for(i in 1:nprobe){
    Yprobe[i]  ~ dnorm(muprobe[i],inv.var)
    muprobe[i] <- beta1[struct.cohort.probe[i]] + beta2[struct.cohort.probe[i]]*DI.scaled.probe[i] + beta3[struct.cohort.probe[i]]*DBH.scaled.probe[i] +beta4[struct.cohort.probe[i]]*log_RWI_1.probe[i] +beta5[struct.cohort.probe[i]]*log_RWI_2.probe[i] + beta6[struct.cohort.probe[i]]*Temp.scaled.probe[i]
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
beta5[s] ~ dnorm(mu_beta5, inv_beta5)
beta6[s] ~ dnorm(mu_beta5, inv_beta6)
}



# use normalpriors for each  beta paramters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)
mu_beta5 ~ dunif(-2, 2)
mu_beta6 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.01, 0.01)
sigma_beta5 <- 1/sqrt(inv_beta5)
inv_beta6   ~ dgamma(0.01, 0.01)
sigma_beta6 <- 1/sqrt(inv_beta6)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


}"





# save these for use later:
saveRDS(train, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/train.rds")
saveRDS(test, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/test.rds")
train <- readRDS("outputs/growth_model/lag2_reg_struct_x_cohort_re_t/train.rds")

# generate probe dataset:
 DIprobe <- seq(range(train$DI.scaled)[1], range(train$DI.scaled)[2], by = 0.75)
 DBHprobe <- seq(range(train$DBH.scaled)[1], range(train$DBH.scaled)[2], by = 0.75)
 Tempprobe <- seq(range(train$T.scaled)[1], range(train$T.scaled)[2], by = 0.75)
 RWI1probe <- seq(range(log(train$RWI_1))[1], range(log(train$RWI_1))[2], by = 0.5)
 RWI2probe <- seq(range(log(train$RWI_2))[1], range(log(train$RWI_2))[2], by = 0.5)
 
 # expand into full probe
probe <- expand.grid(DI.scaled = DIprobe, DBH.scaled = DBHprobe, T.scaled = Tempprobe,
                         RWI_1 = RWI1probe, RWI_2= RWI2probe ,struct.cohort.code= 1:4)



lag2.model.by_structure_x_cohort <- jags.model(textConnection(population_model_structure_x_cohort_re_lag2_temp), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled,log_RWI_1 = log(train$RWI_1),log_RWI_2 = log(train$RWI_2), Temp.scaled = train$T.scaled, struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled, log_RWI_1.p = log(test$RWI_1), log_RWI_2.p = log(test$RWI_2), Temp.scaled.p = test$T.scaled, nprobe = length(probe$DBH.scaled),
   struct.cohort.probe = as.numeric(probe$struct.cohort.code), DBH.scaled.probe = probe$DBH.scaled, DI.scaled.probe = probe$DI.scaled, log_RWI_1.probe = probe$RWI_1, log_RWI_2.probe = probe$RWI_2, Temp.scaled.probe = probe$T.scaled), n.chains = 3, n.adapt = 100)

update(lag2.model.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.cohort.re <- coda.samples(lag2.model.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","beta4","beta5","beta6","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4","sigma_beta5", "sigma_beta6","Yp", "Yprobe"), 
                    n.chains = 3, n.iter=2000, thin = 15)

#summary(samp.structure.cohort.re)
#plot(samp.structure.cohort.re)

#gelman.diag(samp.structure.cohort.re)
#acfplot(samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/lag2_reg_struct_x_cohort_re_t/samps.rds")
  samps <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t/samps.rds")
test <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t/test.rds")
train <- readRDS("outputs//growth_model/lag2_reg_struct_x_cohort_re_t/train.rds")

 Yp.samps <- samps[,1:(length(test$RWI))] 
 Yprobe.samps <- samps[,(length(test$RWI)+1):(length(probe$DI.scaled))] 
 alpha.samps  <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+1):(length(test$RWI)+(length(probe$DI.scaled))+ 4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+5):(length(test$RWI)+ (length(probe$DI.scaled))+8)]
 beta3.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+9):(length(test$RWI)+ (length(probe$DI.scaled))+12)]
 beta4.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+13):(length(test$RWI)+(length(probe$DI.scaled))+ 16)]
 beta5.samps <- samps[,(length(test$RWI)+(length(probe$DI.scaled))+ 17):(length(test$RWI)+(length(probe$DI.scaled))+ 20)]
 beta6.samps <- samps[,(length(test$RWI)+(length(probe$DI.scaled))+ 21):(length(test$RWI)+(length(probe$DI.scaled))+ 24)]
 sigma.samps <- samps[,(length(test$RWI)+ (length(probe$DI.scaled))+25)]
 sigma_betas <- samps[,(length(test$RWI)+(length(probe$DI.scaled))+ 26):(length(test$RWI)+(length(probe$DI.scaled))+ 31)]

 
 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps)) ~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note best model fit so far
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag2_reg_struct_x_cohort_re_t", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)



# get difference between beta2.samps: (i.e are they different?)
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,4], main = "sigma beta4")
dev.off()

png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t/marginal_beta4s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta5 Past-Forest")
hist(beta5.samps[,2], main = "beta5 Modern-Forest")
hist(beta5.samps[,3],  main = "beta5 Past-Savanna")
hist(beta5.samps[,4],  main = "beta5 Modern-Savanna")
hist(sigma_betas[,5], main = "sigma beta5")
dev.off()


png("outputs/growth_model/lag2_reg_struct_x_cohort_re_t/marginal_beta5s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta4 Past-Forest")
hist(beta5.samps[,2], main = "beta4 Modern-Forest")
hist(beta5.samps[,3],  main = "beta4 Past-Savanna")
hist(beta5.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,6], main = "sigma beta4")
dev.off()

# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Drought Index slope")

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag2_reg_struct_x_cohort_re_t/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+ xlim(0, 0.15), b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(paste0("beta5-",c(unique(train$struct.cohort))))
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

library(cowplot)
png(width = 5, height = 10, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, b5.mplots,ncol = 1)
dev.off()

# --------------------make plots of probed predicted growth responses:
# plot probed values of tree growth predictions:
Yprobe <- data.frame(Yprobe.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
probe.m$RWI <- exp(probe.m$value) 
colnames(probe.m) <- c("num", "Ypred", "RWI")

probe$num <- 1:length(probe[,1])
colnames(probe) <- c("Drought", "DBH","Tmax", "RWI_1","RWI_2","struct.cohort", "num")

# summarize by structure + cohort class only:
full.p <- probe
full.p$num <- as.factor(as.character(full.p$num))
prob <- dplyr::inner_join(probe.m, full.p, by=c("num"))


preds_ci <- prob %>% group_by(num, DBH,Drought,Tmax, RWI_1,RWI_2,struct.cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

ggplot(preds_ci, aes(Drought, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~as.factor(DBH))



ggplot(prob, aes(x = Ypred, y = as.factor(Drought))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

# summarize by ageclass only:
prob$ageclass <- ifelse(prob$struct.cohort %in% c("1", "3"),"Past","Modern")
dbh.df <- data.frame(DBH = unique(prob$DBH)[order(unique(prob$DBH))], DBH.class = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm","70cm", "80cm"))


prob <- merge(dbh.df, prob, by = "DBH")

preds_ci_mod_past <- prob %>% group_by( DBH.class,Drought,Tmax,RWI_1,RWI_2, ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

preds_ci_mod_past$DBH.class <- factor(preds_ci_mod_past$DBH.class, levels = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm", "70cm"))
preds_ci_mod_past$PDSI <- unscale(preds_ci_mod_past$Drought, norm.data = DI.scaled)

preds.gg <- ggplot(preds_ci_mod_past, aes(PDSI, meanY, color = as.factor(ageclass)))+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+stat_smooth()+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 


png(height = 8, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/predicted_growth_mod_past_CI.png")
preds.gg
dev.off()


preds_ci_mod_past$ageclass <- factor(preds_ci_mod_past$ageclass, levels = c("Past", "Modern"))
gg.tile.past.mod <- ggplot(preds_ci_mod_past, aes(PDSI, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~ageclass, ncol = 1)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("Palmer Drought Severity Index")+theme_bw(base_size = 12)


png(height = 4, width = 3, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t/predicted_growth_mod_past_tile.png")
gg.tile.past.mod
dev.off()

preds_ci <- prob %>% group_by( DBH, Tmax, Drought, RWI_1, RWI_2, struct.cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

ggplot(preds_ci, aes(Drought, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~as.factor(DBH))



# plot response to sp01-drought for small and large DBH trees in savanna + forest for modern + past
# with sp06 = very droughty, an average prev years growth:
# convert prob$Drought back to MAP:
library(DMwR)
DIprobe <- round(seq(range(train$MAP.scaled)[1], range(train$MAP.scaled)[2], by = 0.75), 3)



prob$DBH <- as.numeric(round(unscale(vals = prob$DBH, norm.data = DBH.scaled))) 
prob$MAP <- as.numeric(round(unscale(vals = prob$Drought, norm.data = MAP.scaled)))
prob$Tmax <- as.numeric(round(unscale(vals = prob$Tmax, norm.data = T.scaled))) 
#prob$DBH <- round(unscale(vals = prob$DBH, norm.data = DBH.scaled)) 
#get labels for structure and cohort


prob_10_60cm_avg <- prob %>% dplyr::filter(DBH == 9 | DBH == 33 | DBH == 69 , Tmax == 68 | Tmax == 88, RWI_1 == 0.034, RWI_2 == 0.103 ) 

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
 prob_10_60cm_avg <- merge(prob_10_60cm_avg,struc.conversion, by  = "struct.cohort")
 
 
preds_ci_10 <- prob_10_60cm_avg %>% group_by(DBH, Drought, Tmax, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

# same thing but with lower than average tree growth the years before:

prob_10_60cm_low <- prob %>% dplyr::filter(DBH == 9 | DBH == 33 | DBH == 69 , Tmax == 68 | Tmax == 88, RWI_1 == -1.466, RWI_2 == -1.397 ) 

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
 prob_10_60cm_low <- merge(prob_10_60cm_low,struc.conversion, by  = "struct.cohort")
 
 
preds_ci_10_low <- prob_10_60cm_low %>% group_by(DBH, Drought, Tmax, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))


#----------- plot drought response by max temperature and Dimaeter

ggplot(preds_ci_10, aes(Drought, meanY, color = cohort))+geom_point()+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+facet_grid(vars(DBH), vars(Tmax))

ggplot(preds_ci_10, aes(Drought, meanY, color = as.factor(DBH)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_grid(vars(cohort) , vars(Tmax))

# same plots but with lower than average tree growth the years before:
ggplot(preds_ci_10_low, aes(Drought, meanY, color = cohort))+geom_point()+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+facet_grid(vars(DBH), vars(Tmax))

ggplot(preds_ci_10_low, aes(Drought, meanY, color = as.factor(DBH)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_grid(vars(cohort) , vars(Tmax))


ggplot(preds_ci_10_low, aes(Drought, DBH, fill = meanY))+geom_tile()+facet_grid(vars(cohort) , vars(Tmax))

# -------plot point estimates of growth based on low moisutre under hot and cold conditions by DBH, colored by cohort x stand, and with facets by previous years growth:

prob_lowMAP <- prob %>% dplyr::filter(MAP == 225 , Tmax == 68 | Tmax == 88 , RWI_1 == -1.466 | RWI_1 == 0.034 | RWI_1 == 1.534 , RWI_2 == -1.397 | RWI_2 == 0.103 | RWI_2 == 1.603 ) 

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
prob_lowMAP <- merge(prob_lowMAP,struc.conversion, by  = "struct.cohort")
 
 
prob_lowMAP_ci <- prob_lowMAP %>% group_by(DBH,  Tmax, RWI_1, RWI_2, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

ggplot(prob_lowMAP_ci[prob_lowMAP_ci$Tmax == 68,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)

ggplot(prob_lowMAP_ci[prob_lowMAP_ci$Tmax == 88,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)

# same but for high MAP
prob_highMAP <- prob %>% dplyr::filter(MAP == 1094 , Tmax == 68 | Tmax == 88 , RWI_1 == -1.466 | RWI_1 == 0.034 | RWI_1 == 1.534 , RWI_2 == -1.397 | RWI_2 == 0.103 | RWI_2 == 1.603 ) 

 struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
prob_highMAP <- merge(prob_highMAP,struc.conversion, by  = "struct.cohort")
 
 
prob_highMAP_ci <- prob_highMAP %>% group_by(DBH,  Tmax, RWI_1, RWI_2, struct.cohort, cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

ggplot(prob_highMAP_ci[prob_highMAP_ci$Tmax == 68,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)+theme_bw()

ggplot(prob_highMAP_ci[prob_highMAP_ci$Tmax == 88,], aes(DBH, meanY, color = cohort))+geom_point()+facet_grid(vars(RWI_1), vars(RWI_2)) + ylim(0,6)+theme_bw()

#ggplot(prob_highMAP_ci[prob_highMAP_ci$RWI_2 == -1.397 & prob_highMAP_ci$RWI_1 == -1.466,], aes(DBH, Tmax,fill = meanY))+geom_tile()+facet_grid(~cohort) 


#------- get sensitivity to temperature by dbh, site, etc.
preds_ci <- prob %>% group_by(num, DBH,Drought,Tmax, RWI_1,RWI_2,struct.cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

ggplot(preds_ci, aes(Drought, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~as.factor(DBH))



ggplot(prob, aes(x = Ypred, y = as.factor(Drought))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

# summarize by ageclass only:
prob$ageclass <- ifelse(prob$struct.cohort %in% c("1", "3"),"Past","Modern")
dbh.df <- data.frame(DBH = unique(prob$DBH)[order(unique(prob$DBH))], DBH.class = c(">5cm", "10cm", "20cm", "30cm", "45cm", "60cm","70cm", "80cm"))


prob <- merge(dbh.df, prob, by = "DBH")

preds_ci_mod_past <- prob %>% group_by( DBH.class,DBH,Drought,Tmax,RWI_1,RWI_2, ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

preds_ci_mod_past$DBH.class <- factor(preds_ci_mod_past$DBH.class, levels = c(">5cm", "20cm", "30cm", "45cm", "60cm", "70cm", "80cm"))


preds.gg <- ggplot(preds_ci_mod_past[preds_ci_mod_past$Tmax == 68 & preds_ci_mod_past$RWI_1 == -1.966  & preds_ci_mod_past$RWI_2 == -1.897,], aes(Drought, meanY, color = as.factor(ageclass)))+geom_line()+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

ggplot(preds_ci_mod_past[preds_ci_mod_past$Tmax == 88 & preds_ci_mod_past$RWI_1 == -1.966  & preds_ci_mod_past$RWI_2 == -1.897,], aes(Drought, meanY, color = as.factor(ageclass)))+geom_line()+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

ggplot(preds_ci_mod_past[preds_ci_mod_past$Tmax == 68 & preds_ci_mod_past$RWI_1 == 0.034  & preds_ci_mod_past$RWI_2 == 0.103,], aes(Drought, meanY, color = as.factor(ageclass)))+geom_line()+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

ggplot(preds_ci_mod_past[preds_ci_mod_past$Tmax == 88 & preds_ci_mod_past$RWI_1 == 0.034  & preds_ci_mod_past$RWI_2 == 0.103,], aes(Drought, meanY, color = as.factor(ageclass)))+geom_line()+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

ggplot(preds_ci_mod_past[preds_ci_mod_past$Tmax == 68 & preds_ci_mod_past$RWI_1 == 1.534  & preds_ci_mod_past$RWI_2 == 1.603,], aes(Drought, meanY, color = as.factor(ageclass)))+geom_line()+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

ggplot(preds_ci_mod_past[preds_ci_mod_past$Tmax == 88 & preds_ci_mod_past$RWI_1 == 1.534  & preds_ci_mod_past$RWI_2 == 1.603,], aes(Drought, meanY, color = as.factor(ageclass)))+geom_line()+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

# plot marginal effects of climate and previous years growth 
# Marginal MAP effect:
preds_ci_mod_past_MAP <- prob %>% group_by( MAP,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_MAP_marg<- ggplot(preds_ci_mod_past_MAP, aes(MAP,meanY, color = ageclass))+geom_smooth(data = preds_ci_mod_past_MAP,aes(x = MAP, y = meanY))+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Mean Predicted Tree growth")+ylim(0.5, 2.5)


# marginal TMAX effect
preds_ci_mod_past_Tmax <- prob %>% group_by( Tmax,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_Tmax_marg<- ggplot(preds_ci_mod_past_Tmax, aes(Tmax,meanY, color = ageclass))+geom_smooth(data = preds_ci_mod_past_Tmax,aes(x = Tmax, y = meanY))+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Mean Predicted Tree growth")+ylim(0.5,2.5)

# marginal DBH effect
preds_ci_mod_past_DBH <- prob %>% group_by( DBH,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_DBH_marg <- ggplot(preds_ci_mod_past_DBH, aes(DBH,meanY, color = ageclass))+geom_smooth(data = preds_ci_mod_past_DBH,aes(x = DBH, y = meanY))+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Mean Predicted Tree growth")+ylim(0.5,2.5)

# marginal lag-1 effect
preds_ci_mod_past_RWI1 <- prob %>% group_by( RWI_1,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_1_marg <- ggplot(preds_ci_mod_past_RWI1, aes(RWI_1,meanY, color = ageclass))+geom_smooth(data = preds_ci_mod_past_RWI1,aes(x = RWI_1, y = meanY))+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Mean Predicted Tree growth")+xlab("Previous (-1) Year's growth")+ylim(0, 4)

# marginal lag-2 effect
preds_ci_mod_past_RWI2 <- prob %>% group_by( RWI_2,ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_2_marg<- ggplot(preds_ci_mod_past_RWI2, aes(RWI_2,meanY, color = ageclass))+geom_smooth(aes(x = RWI_2, y = meanY))+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab("Mean Predicted Tree growth")+ylim(0, 4)+xlab("-2 Year's growth")



png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_post_predictive_effects_ageclass.png")
plot_grid(Y_MAP_marg, Y_Tmax_marg, Y_DBH_marg,Y_RWI_1_marg, Y_RWI_2_marg, align = "v", nrow = 3)
dev.off()

# --------------plot marginal effects for each stand structure and cohort class:
struc.conversion <- data.frame(struct.cohort = 1:4, cohort = c(paste0(c(unique(train$struct.cohort)))))
prob <- merge(prob, struc.conversion, by  = "struct.cohort")
 
# plot marginal effects of climate and previous years growth 
# Marginal MAP effect:
preds_ci_mod_past_MAP <- prob %>% group_by( MAP,cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_MAP_marg_c <- ggplot(preds_ci_mod_past_MAP, aes(MAP,meanY, color = cohort))+geom_smooth(data = preds_ci_mod_past_MAP,aes(x = MAP, y = meanY))+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) + ylab("Mean Predicted Tree growth")+ylim(0.5, 2.5)


# marginal TMAX effect
preds_ci_mod_past_Tmax <- prob %>% group_by( Tmax, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_Tmax_marg_c <- ggplot(preds_ci_mod_past_Tmax, aes(Tmax,meanY, color = cohort))+geom_smooth(data = preds_ci_mod_past_Tmax,aes(x = Tmax, y = meanY))+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) + ylab("Mean Predicted Tree growth")+ylim(0.5,2.5)

# marginal DBH effect
preds_ci_mod_past_DBH <- prob %>% group_by( DBH, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_DBH_marg_c <- ggplot(preds_ci_mod_past_DBH, aes(DBH,meanY, color = cohort))+geom_smooth(data = preds_ci_mod_past_DBH,aes(x = DBH, y = meanY))+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))  + ylab("Mean Predicted Tree growth")+ylim(0.5,2.5)

# marginal lag-1 effect
preds_ci_mod_past_RWI1 <- prob %>% group_by( RWI_1, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_1_marg_c <- ggplot(preds_ci_mod_past_RWI1, aes(RWI_1,meanY, color = cohort))+geom_smooth(data = preds_ci_mod_past_RWI1,aes(x = RWI_1, y = meanY))+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))  + ylab("Mean Predicted Tree growth")+xlab("Previous (-1) Year's growth")+ylim(0, 4)

# marginal lag-2 effect
preds_ci_mod_past_RWI2 <- prob %>% group_by( RWI_2, cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))

Y_RWI_2_marg_c <- ggplot(preds_ci_mod_past_RWI2, aes(RWI_2,meanY, color = cohort))+geom_smooth(aes(x = RWI_2, y = meanY))+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) + ylab("Mean Predicted Tree growth")+ylim(0, 4)+xlab("-2 Year's growth")



png(height = 10, width = 10, units = "in", res = 300, "outputs/growth_model/lag2_reg_struct_x_cohort_re_t_pr/marginal_post_predictive_effects_ageclass_cohort.png")
plot_grid(Y_MAP_marg_c, Y_Tmax_marg_c, Y_DBH_marg_c,Y_RWI_1_marg_c, Y_RWI_2_marg_c, align = "v", nrow = 3)
dev.off()




```

#model with stand structure by ageclass random effects and prev years growth (lag -1) and (lag - 2), but not log transformed:
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
model_structure_x_cohort_re_lag2 <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]+beta4[struct.cohort[i]]*log_RWI_1[i]+beta5[struct.cohort[i]]*log_RWI_2[i]   # use Drought index as a scaled variable 

#r1[i] <- Y[i] - gfunc[i]   

}

#RSS[1] <- sum(r1^2)

# Prediction
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] +beta4[struct.cohort.p[i]]*log_RWI_1.p[i] +beta5[struct.cohort.p[i]]*log_RWI_2.p[i] 
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
beta5[s] ~ dnorm(mu_beta5, inv_beta5)

}



# use normalpriors for each  beta paramters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)
mu_beta5 ~ dunif(-2, 2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.01, 0.01)
sigma_beta5 <- 1/sqrt(inv_beta5)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


}"





# save these for use later:
saveRDS(train, "outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/train.rds")
saveRDS(test, "outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/test.rds")



lag2.model.by_structure_x_cohort <- jags.model(textConnection(model_structure_x_cohort_re_lag2), 
                    data = list(Y=train$RWI, n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled,log_RWI_1 = log(train$RWI_1),log_RWI_2 = train$RWI_2, struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled, log_RWI_1.p = test$RWI_1, log_RWI_2.p = test$RWI_2), n.chains = 3, n.adapt = 100)

update(lag2.model.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.cohort.re <- coda.samples(lag2.model.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","beta4","beta5","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4","sigma_beta5","Yp"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.cohort.re)
#plot(samp.structure.cohort.re)

#gelman.diag(samp.structure.cohort.re)
#acfplot(samp.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.cohort.re[[1]]
 saveRDS(samps, "outputs//growth_model/lag2_untrans_reg_struct_x_cohort_re/samps.rds")
  samps <- readRDS("outputs//growth_model/lag2_untrans_reg_struct_x_cohort_re/samps.rds")

 Yp.samps <- samps[,1:(length(test$RWI))] 
 alpha.samps  <- samps[,(length(test$RWI)+ 1):(length(test$RWI)+ 4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+ 5):(length(test$RWI)+ 8)]
 beta3.samps <- samps[,(length(test$RWI)+ 9):(length(test$RWI)+ 12)]
 beta4.samps <- samps[,(length(test$RWI)+ 13):(length(test$RWI)+ 16)]
 beta5.samps <- samps[,(length(test$RWI)+ 17):(length(test$RWI)+ 20)]
 sigma.samps <- samps[,(length(test$RWI)+ 21)]
 sigma_betas <- samps[,(length(test$RWI)+ 22):(length(test$RWI)+ 26)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(Yp.samps)~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(Yp.samps)-test$RWI)^2)
BIAS1  <- mean(colMeans(Yp.samps)-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "lag2_untrans_reg_struct_x_cohort_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)



# get difference between beta2.samps: (i.e are they different?)
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/llag2_untrans_reg_struct_x_cohort_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png("outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
hist(sigma_betas[,4], main = "sigma beta4")
dev.off()

png("outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/marginal_beta3s.png")
par(mfrow=c(3,2))
hist(beta5.samps[,1], main = "beta5 Past-Forest")
hist(beta5.samps[,2], main = "beta5 Modern-Forest")
hist(beta5.samps[,3],  main = "beta5 Past-Savanna")
hist(beta5.samps[,4],  main = "beta5 Modern-Savanna")
hist(sigma_betas[,5], main = "sigma beta5")
dev.off()

# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Drought Index slope")

b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c( "Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 6, width = 12, units = "in", res = 300,"outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+ xlim(0, 0.15), b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.6))
dev.off()

# plot slightly differently:
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Modern-Forest"), "Forest", "Savanna")

plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels= c("Past", "Modern"))

b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black(base_size = 18)+facet_wrap(~forestclass)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("Estimated Drought Sensitivity")

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct_rb.png")
b2.dots.2
dev.off()

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(paste0("beta5-",c(unique(train$struct.cohort))))
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("lag - 1 effect")

library(cowplot)
png(width = 5, height = 10, units = "in", res = 300, "outputs/growth_model/lag2_untrans_reg_struct_x_cohort_re/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, b5.mplots,ncol = 1)
dev.off()

```

# model for cohort effects and site level effects, heirarchically:
```{r}

cohort_model_site_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[cohort[i]] + beta2[cohort[i]]*DI.scaled[i] + beta3[cohort[i]]*DBH.scaled[i] + beta4[cohort[i]]*log_RWI_1[i]  # use Drought index as a scaled variable 
}



# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
beta4[s] ~ dnorm(mu_beta4[plot[s]], inv_beta4)



}


for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)
mu_beta4[j] ~ dnorm(0, 0.5)
}

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.001, 0.001)
sigma_beta4 <- 1/sqrt(inv_beta4)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)


for(i in 1:np){
# process model
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1[cohort.p[i]] + beta2[cohort.p[i]]*DI.scaled.p[i] + beta3[cohort.p[i]]*DBH.scaled.p[i] + beta4[cohort.p[i]]*log_RWI_1.p[i]  # use Drought index as a scaled variable 
}

}"






cohort.model.re_lag <- jags.model(textConnection(cohort_model_site_re), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, log_RWI_1 = log(train$RWI_1), cohort = as.numeric(train$ageclass), S = unique(train$ageclass),
                    plot = as.numeric(train$site), ind = unique(train$site), np = length(test$DBH.scaled), DI.scaled.p = test$DI.scaled, DBH.scaled.p = test$DBH.scaled, log_RWI_1.p = log(test$RWI_1),cohort.p = as.numeric(test$ageclass), SP = unique(test$ageclass),
                    plot.p = as.numeric(test$site), ind.p = unique(test$site)), n.chains = 3, n.adapt = 100)

update(cohort.model.re_lag, 2000); # Burnin for 1000 samples to start, then go higher later

samp <- coda.samples(cohort.model.re_lag, 
                     variable.names=c("beta1", "beta2","beta3","beta4","sigma", "sigma_beta1", "sigma_beta2", "sigma_beta3","sigma_beta4", "mu_beta1", "mu_beta2", "mu_beta3","mu_beta3", "Yp"), 
                    n.chains = 3, n.iter=20000, thin = 10)

#summary(samp)
#traceplot(samp)
#gelman.diag(samp)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp[[1]]
 saveRDS(samps, "outputs/growth_model/basic_reg_cohort_site_re/samps.rds")
samps <-  readRDS("outputs/growth_model/basic_reg_cohort_site_re/samps.rds")
 Yp.samps    <- samps[,1:length(test$RWI)] 
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 alpha.samps  <- samps[,((length(test$RWI)+1)):((length(test$RWI)+2))]
 beta2.samps <- samps[,((length(test$RWI)+3)):((length(test$RWI)+4))]
 beta3.samps <- samps[,((length(test$RWI)+5)):((length(test$RWI)+6))]
  beta4.samps <- samps[,((length(test$RWI)+7)):((length(test$RWI)+8))]
 mu_beta1.samps <- samps[,((length(test$RWI)+9)):((length(test$RWI)+24))]
 mu_beta2.samps <- samps[,((length(test$RWI)+25)):((length(test$RWI)+40))]
 mu_beta3.samps <- samps[,((length(test$RWI)+41)):((length(test$RWI)+56))]
 sigma.samps <- samps[,((length(test$RWI)+57))]
 sigma_betas <- samps[,((length(test$RWI)+58)):((length(test$RWI)+61))]

 
 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/basic_reg_cohort_site_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "basic_reg_cohort_site_re_with_lag", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)

 
png("outputs/growth_model/basic_reg_cohort_site_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past")
hist(alpha.samps[,2], main = "alpha Modern")
#hist(alpha.samps[,3],  main = "alpha Past-Forest")
#hist(alpha.samps[,4],  main = "alpha Modern-Forest")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/basic_reg_cohort_site_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Savanna")
hist(beta2.samps[,2], main = "beta2 Modern-Savanna")
#hist(beta2.samps[,3],  main = "beta2 Past-Forest")
#hist(beta2.samps[,4],  main = "beta2 Modern-Forest")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()





png("outputs/growth_model/basic_reg_cohort_site_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Savanna")
hist(beta3.samps[,2], main = "beta3 Modern-Savanna")
#hist(beta3.samps[,3],  main = "beta3 Past-Forest")
#hist(beta3.samps[,4],  main = "beta3 Modern-Forest")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_cohort_site_re/marginal_mu_beta2s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta3.samps))){
  hist(mu_beta2.samps[,i], main = paste(colnames(mu_beta2.samps)[i]))
}
dev.off()


png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_cohort_site_re/marginal_mu_beta3s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta3.samps))){
  hist(mu_beta3.samps[,i], main = paste(colnames(mu_beta3.samps)[i]))
}
dev.off()

png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_cohort_site_re/marginal_mu_beta1s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta1.samps))){
  hist(mu_beta1.samps[,i], main = paste(colnames(mu_beta1.samps)[i]))
}
dev.off()

# plot predicted vs. observed:
png("outputs/growth_model/basic_reg_cohort_site_re/pred_vs_obs.png")
plot(colMeans(exp(Yp.samps)), test$RWI) 
abline(a = 0, b = 1, col = "red")
dev.off()



# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0( c("Modern", "Past")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bw = 0.005)+theme_bw()+xlab("Random intercepts")+theme_black()

a.mean <- apply(as.matrix(a[,1:2]), 2, mean)
a.lower <- apply(as.matrix(a[,1:2]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:2]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat <- data.frame(a.mean, a.lower, a.upper)
plot.dat$class <- row.names(plot.dat)

a.dots <- ggplot(plot.dat, aes(x = a.mean,y = class, color = class))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 1,height = 0)+geom_point()+xlim(-0.1, 0.05)+theme_black()+coord_flip()+theme(legend.position = "none")+xlab("Estimated Intercept")

plot_grid(a.dots, alpha.mplots+coord_flip()+ xlim(-0.1, 0.05)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))



b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c("Modern", "Past")))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bw = 0.005)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black()

b2.mean <- apply(as.matrix(b2[,1:2]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:2]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:2]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 1,height = 0)+geom_point()+xlim(0, 0.15)+theme_black()+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png("outputs/growth_model/basic_reg_cohort_site_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots, b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))
dev.off()



b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c("Modern", "Past")))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")+theme_black()

library(cowplot)
png(width = 5, height = 6, units = "in", res = 300, "outputs/growth_model/basic_reg_cohort_site_re/param_marginal_distn_bycohort.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()

# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 beta3.mn  <- colMeans(beta3.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 
 #mu_beta1.samps <- colMeans(mu_beta1.samps) 
 #mu_beta2.samps <- colMeans(mu_beta2.samps) 
 #mu_beta3.samps <- colMeans(mu_beta3.samps) 


# get posterior predictions:
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  cohort= 1:2, site = as.numeric(unique(full.ghcn$site)))
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:



 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 
 
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

        
        alpha1.mn <- rnorm(1000, mu_beta1.samps[Xp[j,4]], mean(sigma_betas[,1]) ) # check the sigma betas
        beta2.mn <- rnorm(1000, mu_beta2.samps[Xp[j,4]], mean(sigma_betas[,2]) ) # check the sigma betas
        beta3.mn <- rnorm(1000, mu_beta3.samps[Xp[j,3]], mean(sigma_betas[,3]) ) # check the sigma betas
       
   mu <- alpha1.mn + beta2.mn*Xp[j,1] + beta2.mn*Xp[j,2]   # use
   
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   
   ypred[[j]]  <- mu
  # lines(density(y),col=2)
   
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)


Xp$MeanY <- exp(rowMeans(ypred.df))

Xp$cohort <- ifelse(Xp$cohort == 2, "Past",  
                       ifelse(Xp$cohort == 1, "Modern",NA))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1, MeanY, color = as.factor(site), shape = as.factor(cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_DBH_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(cohort))
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_DBH_site.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(site))
dev.off()


png(height = 10, width = 10, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_DBH_site_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(site) + as.factor(cohort))
dev.off()

```

# this is the same as above, but we include both cohort and structure as RE
```{r}

site_model_structure_x_cohort_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]   # use Drought index as a scaled variable 


}

# Prediction of test data
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] 
  }

# Prediction of probe data for plotting:
  for(i in 1:nprobe){
    Yprobe[i]  ~ dnorm(muprobe[i],inv.var)
    muprobe[i] <- beta1[struct.cohort.probe[i]] + beta2[struct.cohort.probe[i]]*DI.scaled.probe[i] + beta3[struct.cohort.probe[i]]*DBH.scaled.probe[i] 
  }


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
}


for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)

}

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)





}"





# save these for use later:
saveRDS(train, "outputs/growth_model/site_reg_structure_cohort_re/train.rds")
saveRDS(test, "outputs/growth_model/site_reg_structure_cohort_re/test.rds")

# generate fake data to predict on:
# we want to plot growth relationship to PDSI for Mod/Past in Sav/Forest in small and large DBH:
library(DMwR)

unscale(vals = 2.9355, norm.data = DBH.scaled) # 80 cm
unscale(vals = 2.305, norm.data = DBH.scaled) # 70 cm
unscale(vals = 1.6745, norm.data = DBH.scaled) # 60 cm
unscale(vals = 1.0441, norm.data = DBH.scaled) # 50 cm
unscale(vals = 0.414, norm.data = DBH.scaled) # 40 cm
unscale(vals = -0.217, norm.data = DBH.scaled) # 30 cm
unscale(vals = -0.8469, norm.data = DBH.scaled) # 20 cm
unscale(vals = -1.4775, norm.data = DBH.scaled) # 10 cm


 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 DI.p <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBH.p <- c(2.9355,2.305,1.0441,0.414, -0.217, -0.8469, -1.4775 )# for 40 cm, 30 cm, 20cm, and 10 cm trees respectivly
 full.p <- expand.grid(DI.p, DBH.p,  struct.cohort= 1:4)
 
 

 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 
 Xp <- full.probe
 np <- length(Xp$Var1)


reg.model.site_structure_x_cohort <- jags.model(textConnection(site_model_structure_x_cohort_re ), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, struct.cohort = as.numeric(train$struct.cohort.code), S = unique(train$struct.cohort.code), plot = as.numeric(train$site), ind = unique(train$site),np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled, 
   nprobe = length(full.p$Var1),
   struct.cohort.probe = as.numeric(full.p$struct.cohort), DBH.scaled.probe = full.p$Var2, DI.scaled.probe = full.p$Var1
   ), n.chains = 3, n.adapt = 100)

update(reg.model.site_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.site.cohort.re <- coda.samples(reg.model.site_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "Yp", "Yprobe"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.site.cohort.re)
#plot(samp.structure.site.cohort.re)

#gelman.diag(samp.structure.site.cohort.re)
#acfplot(samp.structure.site.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.site.cohort.re[[1]]
 saveRDS(samps, "outputs/growth_model/site_reg_structure_cohort_re/samps.rds")
 test  <- readRDS(test, "outputs/growth_model/site_reg_structure_cohort_re/test.rds")
 
 Yp.samps <- samps[,1:length(test$RWI)] 
 Yprobe.samps <-samps [,(length(test$RWI)+ 1):(length(test$RWI)+ length(full.p$Var1))]
 alpha.samps  <- samps[,(length(test$RWI)+length(full.p$Var1)+1):(length(test$RWI)+length(full.p$Var1)+4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+5):(length(test$RWI)+length(full.p$Var1)+8)]
 beta3.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+9):(length(test$RWI)+length(full.p$Var1)+12)]
 sigma.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+13)]
 sigma_betas <- samps[,(length(test$RWI)+length(full.p$Var1)+14):(length(test$RWI)+length(full.p$Var1)+16)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "site_reg_structure_cohort_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)

# get difference between beta2.samps:
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/site_reg_structure_cohort_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab(" random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab("Drought random slopes")

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab("DBH random slopes")


library(cowplot)
png(width = 5, height = 6, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()


# plot probed values of tree growth predictions:
Yprobe <- data.frame(Yprobe.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
probe.m$RWI <- exp(probe.m$value) 
colnames(probe.m) <- c("num", "Ypred", "RWI")

full.p$num <- 1:length(full.p[,1])
colnames(full.p) <- c("Drought", "DBH", "struct.cohort", "num")

# summarize by structure + cohort class only:
prob <- merge(probe.m, full.p, by = "num")
preds_ci <- prob %>% group_by(num, DBH,Drought, struct.cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

ggplot(preds_ci, aes(Drought, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~as.factor(DBH))

ggplot(prob, aes(x = Ypred, y = as.factor(Drought))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

# summarize by ageclass only:
prob$ageclass <- ifelse(prob$struct.cohort %in% c("1", "3"),"Past","Modern")
dbh.df <- data.frame(DBH = unique(prob$DBH)[order(unique(prob$DBH))], DBH.class = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm","70cm"))


prob <- merge(dbh.df, prob, by = "DBH")

preds_ci_mod_past <- prob %>% group_by( DBH.class,Drought, ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

preds_ci_mod_past$DBH.class <- factor(preds_ci_mod_past$DBH.class, levels = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm", "70cm"))
preds_ci_mod_past$PDSI <- unscale(preds_ci_mod_past$Drought, norm.data = DI.scaled)

preds.gg <- ggplot(preds_ci_mod_past, aes(PDSI, meanY, color = as.factor(ageclass)))+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+stat_smooth()+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 


png(height = 8, width = 8, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re/predicted_growth_mod_past_CI.png")
preds.gg
dev.off()


preds_ci_mod_past$ageclass <- factor(preds_ci_mod_past$ageclass, levels = c("Past", "Modern"))
gg.tile.past.mod <- ggplot(preds_ci_mod_past, aes(PDSI, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~ageclass, ncol = 1)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("Palmer Drought Severity Index")+theme_bw(base_size = 12)


png(height = 4, width = 3, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re/predicted_growth_mod_past_tile.png")
gg.tile.past.mod
dev.off()


# do the same thing, but just for age structure:
preds_ci_age_struct <- prob %>% group_by(Drought, struct.cohort, DBH.class) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

preds_ci_age_struct$PDSI <- unscale(preds_ci_age_struct$Drought, norm.data = DI.scaled)

ggplot(preds_ci_age_struct, aes(PDSI, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()

# rename cohort structure numbers to text
cohort.df <- data.frame(cohorts = unique(full.ghcn$struct.cohort)[order(unique(full.ghcn$struct.cohort.code))],
           struct.cohort = 1:4)

preds_ci_age_struct <- merge(cohort.df, preds_ci_age_struct, by = "struct.cohort")
preds_ci_age_struct$cohorts <- factor(preds_ci_age_struct$cohorts, levels =c("Past-Forest", 
                                                                             "Past-Savanna", 
                                                                             "Modern-Forest", 
                                                                             "Modern-Savanna") )

#create tile plots of growth responses over time:
gg.tile.past.mod.cohort <- ggplot(preds_ci_age_struct, aes(PDSI, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~cohorts, ncol = 2)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("Palmer Drought Severity Index")+theme_bw(base_size = 12)

png(height = 4, width = 6, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re/predicted_growth_mod_past_forest_sav_tile.png")
gg.tile.past.mod.cohort
dev.off()



# or we can do the comparisons by hand:
Yp <- data.frame(Yp.samps)
colnames(Yp) <- c(paste0("YP-",test$site))
Yp$num <- rownames(Yp)
Yp.m <- melt(Yp, id.vars=c("num"))


ggplot(Yp.m, aes(value, color = as.factor(Yp.m$variable)))+geom_density(alpha = 0.5)+theme_bw()

library(ggridges)

ggplot(Yp.m, aes(x = value, y = as.factor(DI.index))) + 
  geom_density_ridges()

ggplot(full.ghcn, aes(x = log(RWI), y = as.factor(struct.cohort))) + 
  geom_density_ridges()

# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta2.samps)
 beta2.mn  <- colMeans(beta3.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 


# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 ypred.yp <- list()
 diff <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- rnorm(np, mu, sigma.mn)
  # lines(density(y),col=2)
   #ypred.yp[[j]] <- Yp.samps[,j]
   #diff[[j]] <- ypred[[j]] - Yp.samps[[j]]
   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)
#diff.df <- do.call(rbind, diff)
#ypred.yp.df <- do.call(rbind, ypred.yp)

Xp$MeanY <- exp(rowMeans(ypred.df))
#Xp$MeanYhat <- exp(rowMeans(ypred.yp.df))# get the means of the posterior to plot the overall effects of 
Xp$struct.cohort <- ifelse(Xp$struct.cohort == 1, "Past-Forest",  
                       ifelse(Xp$struct.cohort == 2, "Modern-Forest",
                               ifelse(Xp$struct.cohort == 3, "Past-Savanna", 
                                       ifelse(Xp$struct.cohort == 4, "Modern-Savanna", NA))))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/site_reg_structure_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(struct.cohort)))+xlab("Drought Index")+geom_point()+ylab("predicted growth")+stat_smooth()
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/site_reg_structure_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")+stat_smooth()
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/site_reg_structure_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
dev.off()

```




# this is the same as above, but we include both cohort and structure as RE, but no random intercept for structure/cohort:
```{r}

site_model_structure_x_cohort_re_slopes <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1 + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]   # use Drought index as a scaled variable 


}

# Prediction
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1 + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] 
  }

# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
#beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
}


for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
#mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)

}

beta1 ~ dnorm(0, inv_beta1)
inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)





}"





reg.model.site_structure_x_cohort_slopes <- jags.model(textConnection(site_model_structure_x_cohort_re_slopes ), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, struct.cohort = as.numeric(train$struct.cohort.code), S = unique(train$struct.cohort.code), plot = as.numeric(train$site), ind = unique(train$site),np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$DI.scaled), n.chains = 3, n.adapt = 100)

update(reg.model.site_structure_x_cohort_slopes, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.site.cohort.re.slopes <- coda.samples(reg.model.site_structure_x_cohort_slopes, 
                     variable.names=c("beta1", "beta2","beta3","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "Yp"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.site.cohort.re.slopes)
#plot(samp.structure.site.cohort.re.slopes)

#gelman.diag(samp.structure.site.cohort.re.slopes)
#acfplot(samp.structure.site.cohort.re.slopes)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.site.cohort.re.slopes[[1]]
 saveRDS(samps, "outputs/growth_model/site_reg_structure_cohort_re.slopes/samps.rds")
 #Yp.samps    <- samps[,1] 
 Yp.samps <- samps[,1:length(test$RWI)] 
 alpha.samps  <- samps[,(length(test$RWI)+1)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+2):(length(test$RWI)+6)]
 beta3.samps <- samps[,(length(test$RWI)+7):(length(test$RWI)+10)]
 sigma.samps <- samps[,(length(test$RWI)+11)]
 sigma_betas <- samps[,(length(test$RWI)+12):(length(test$RWI)+13)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re.slopes/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "site_reg_structure_cohort_re.slopes", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)

# get difference between beta2.samps:
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/site_reg_structure_cohort_re.slopes/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re.slopes/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re.slopes/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab(" random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.003)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black()+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)

b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0, 0.15)+theme_black()+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png("outputs/growth_model/site_reg_structure_cohort_re.slopes/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots, b2.mplots+coord_flip()+ xlim(0, 0.15)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))
dev.off()


b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab("DBH random slopes")

 ggplot(b3.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab("DBH random slopes")

b3.boxplots <- ggplot(b3.m, aes(y = value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_bw()+xlab("DBH slope")+theme_black()

library(cowplot)
png(width = 5, height = 6, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re.slopes/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()


Yp <- data.frame(Yp.samps)
colnames(Yp) <- c(paste0("YP-",test$site))
Yp$num <- rownames(Yp)
Yp.m <- melt(Yp, id.vars=c("num"))
#Yp.m$DBHindex <- Xp$Var2
#Yp.m$DIindex <- Xp$Var1
#Yp.m$struct.cohort <- Xp$struct.cohort

ggplot(Yp.m, aes(value, color = as.factor(Yp.m$variable)))+geom_density(alpha = 0.5)+theme_bw()

library(ggridges)

ggplot(Yp.m, aes(x = value, y = as.factor(DIindex))) + 
  geom_density_ridges()

ggplot(full.ghcn, aes(x = log(RWI), y = as.factor(struct.cohort))) + 
  geom_density_ridges()

# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta2.samps)
 beta2.mn  <- colMeans(beta3.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 


# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 ypred.yp <- list()
 diff <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- rnorm(np, mu, sigma.mn)
  # lines(density(y),col=2)
   #ypred.yp[[j]] <- Yp.samps[,j]
   #diff[[j]] <- ypred[[j]] - Yp.samps[[j]]
   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)
#diff.df <- do.call(rbind, diff)
#ypred.yp.df <- do.call(rbind, ypred.yp)

Xp$MeanY <- exp(rowMeans(ypred.df))
#Xp$MeanYhat <- exp(rowMeans(ypred.yp.df))# get the means of the posterior to plot the overall effects of 
Xp$struct.cohort <- ifelse(Xp$struct.cohort == 1, "Past-Forest",  
                       ifelse(Xp$struct.cohort == 2, "Modern-Forest",
                               ifelse(Xp$struct.cohort == 3, "Past-Savanna", 
                                       ifelse(Xp$struct.cohort == 4, "Modern-Savanna", NA))))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/site_reg_structure_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(struct.cohort)))+xlab("Drought Index")+geom_point()+ylab("predicted growth")+stat_smooth()
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/site_reg_structure_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")+stat_smooth()
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/site_reg_structure_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
dev.off()


```

Model with cohort RE and SPEI-6 month July lags
```{r}

site_model_structure_x_cohort_re_SP6_06 <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]+ beta4[struct.cohort[i]]*log_RWI_1[i]   # use Drought index as a scaled variable 


}

# Prediction of test data
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] + beta4[struct.cohort.p[i]]*log_RWI_1.p[i]
  }

# Prediction of probe data for plotting:
  for(i in 1:nprobe){
    Yprobe[i]  ~ dnorm(muprobe[i], inv.var)
    muprobe[i] <- beta1[struct.cohort.probe[i]] + beta2[struct.cohort.probe[i]]*DI.scaled.probe[i] + beta3[struct.cohort.probe[i]]*DBH.scaled.probe[i] + beta4[struct.cohort.probe[i]]*log_RWI_1.probe[i]
  }


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
beta4[s] ~ dnorm(mu_beta4[plot[s]], inv_beta4)
}


for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)
mu_beta4[j] ~ dnorm(0, 0.5)
}

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.001, 0.001)
sigma_beta4 <- 1/sqrt(inv_beta4)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)


}"





# save these for use later:
saveRDS(train, "outputs/growth_model/site_reg_structure_cohort_re_sp6/train.rds")
saveRDS(test, "outputs/growth_model/site_reg_structure_cohort_re_sp6/test.rds")

# generate fake data to predict on:
# we want to plot growth relationship to PDSI for Mod/Past in Sav/Forest in small and large DBH:
library(DMwR)

unscale(vals = 2.9355, norm.data = DBH.scaled) # 80 cm
unscale(vals = 2.305, norm.data = DBH.scaled) # 70 cm
unscale(vals = 1.6745, norm.data = DBH.scaled) # 60 cm
unscale(vals = 1.0441, norm.data = DBH.scaled) # 50 cm
unscale(vals = 0.414, norm.data = DBH.scaled) # 40 cm
unscale(vals = -0.217, norm.data = DBH.scaled) # 30 cm
unscale(vals = -0.8469, norm.data = DBH.scaled) # 20 cm
unscale(vals = -1.4775, norm.data = DBH.scaled) # 10 cm


 SPprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 DI.p <- seq(range(full.ghcn$SP06_6)[1], range(full.ghcn$SP06_6)[2], by = 0.5)
 DBH.p <- c(2.9355, 2.305,1.0441,0.414, -0.217, -0.8469, -1.4775 )# for 40 cm, 30 cm, 20cm, and 10 
  log_RWI_1.probe <- seq(range(log(test$RWI_1))[1], range(log(test$RWI_1))[2], by = 0.25)
#cm trees respectivly
 full.probe <- expand.grid(DI.probe = DI.p, DBH.probe = DBH.p,  log_RWI_1.probe = log_RWI_1.probe,struct.cohort= 1:4)
 
 

 # something like:
#full.probe <- expand.grid( DI.p, DBH.p, log_RWI_1.probe,  struct.cohort= 1:4 )
 
 Xp <- full.probe
 np <- length(Xp$Var1)


reg.model.site_structure_x_cohort_sp6 <- jags.model(textConnection(site_model_structure_x_cohort_re_SP6_06 ), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$SP06_6, DBH.scaled = train$DBH.scaled, log_RWI_1 = log(train$RWI_1), struct.cohort = as.numeric(train$struct.cohort.code), S = unique(train$struct.cohort.code), plot = as.numeric(train$site), ind = unique(train$site),np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$SP06_6, log_RWI_1.p = log(test$RWI_1),
   nprobe = length(full.probe$DI.probe),
   struct.cohort.probe = as.numeric(full.probe$struct.cohort), DBH.scaled.probe = full.probe$DBH.probe, DI.scaled.probe = full.probe$DI.probe, log_RWI_1.probe = full.probe$log_RWI_1.probe
   ), n.chains = 3, n.adapt = 100)

update(reg.model.site_structure_x_cohort_sp6, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.site.cohort.re.sp6 <- coda.samples(reg.model.site_structure_x_cohort_sp6, 
                     variable.names=c("beta1", "beta2","beta3","beta4","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3","sigma_beta4", "Yp", "Yprobe"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.site.cohort.re.sp6)
#plot(samp.structure.site.cohort.re.sp6)

#gelman.diag(samp.structure.site.cohort.re.sp6)
#acfplot(samp.structure.site.cohort.re.sp6)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.site.cohort.re.sp6[[1]]
 saveRDS(samps, "outputs/growth_model/site_reg_structure_cohort_re_sp6/samps.rds")
 test  <- readRDS(test, "outputs/growth_model/site_reg_structure_cohort_re_sp6/test.rds")
 
 Yp.samps <- samps[,1:length(test$RWI)] 
 Yprobe.samps <-samps [,(length(test$RWI)+ 1):(length(test$RWI)+ length(full.probe$DI.probe))]
 alpha.samps  <- samps[,(length(test$RWI)+length(full.probe$DI.probe)+1):(length(test$RWI)+length(full.probe$DI.probe)+4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+length(full.probe$DI.probe)+5):(length(test$RWI)+length(full.probe$DI.probe)+8)]
 beta3.samps <- samps[,(length(test$RWI)+length(full.probe$DI.probe)+9):(length(test$RWI)+length(full.probe$DI.probe)+12)]
  beta4.samps <- samps[,(length(test$RWI)+length(full.probe$DI.probe)+13):(length(test$RWI)+length(full.probe$DI.probe)+16)]
 sigma.samps <- samps[,(length(test$RWI)+length(full.probe$DI.probe)+17)]
 sigma_betas <- samps[,(length(test$RWI)+length(full.probe$DI.probe)+18):(length(test$RWI)+length(full.probe$DI.probe)+21)]

 

# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp6/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "site_reg_structure_cohort_re_sp6", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)



# get difference between beta2.samps:
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/site_reg_structure_cohort_re_sp6/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp6/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp6/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab(" random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.05, alpha = 0.5)+theme_black()+ylab("frequency")+xlab("Drought random slopes")

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.05, alpha = 0.5)+theme_black()+ylab("frequency")+xlab("DBH random slopes")


library(cowplot)
png(width = 5, height = 6, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp6/param_marginal_distn_bycohort_struct.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()


# plot probed values of tree growth predictions:
Yprobe <- data.frame(Yprobe.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
probe.m$RWI <- exp(probe.m$value) 
colnames(probe.m) <- c("num", "Ypred", "RWI")

full.p$num <- 1:length(full.p[,1])
colnames(full.p) <- c("Drought", "DBH", "struct.cohort", "num")

# summarize by structure + cohort class only:
prob <- merge(probe.m, full.p, by = "num")
preds_ci <- prob %>% group_by(num, DBH,Drought, struct.cohort) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

ggplot(preds_ci, aes(Drought, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~as.factor(DBH))

ggplot(prob, aes(x = Ypred, y = as.factor(Drought))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

# summarize by ageclass only:
prob$ageclass <- ifelse(prob$struct.cohort %in% c("1", "3"),"Past","Modern")
dbh.df <- data.frame(DBH = unique(prob$DBH)[order(unique(prob$DBH))], DBH.class = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm","70cm"))


prob <- merge(dbh.df, prob, by = "DBH")

preds_ci_mod_past <- prob %>% group_by( DBH.class,Drought, ageclass) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

preds_ci_mod_past$DBH.class <- factor(preds_ci_mod_past$DBH.class, levels = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm", "70cm"))
preds_ci_mod_past$PDSI <- unscale(preds_ci_mod_past$Drought, norm.data = DI.scaled)

preds.gg <- ggplot(preds_ci_mod_past, aes(Drought, meanY, color = as.factor(ageclass)))+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+stat_smooth()+facet_wrap(~DBH.class)+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 


png(height = 8, width = 8, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp6/predicted_growth_mod_past_CI.png")
preds.gg
dev.off()


preds_ci_mod_past$ageclass <- factor(preds_ci_mod_past$ageclass, levels = c("Past", "Modern"))
gg.tile.past.mod <- ggplot(preds_ci_mod_past, aes(Drought, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~ageclass, ncol = 1)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SPEI - 6 month")+theme_bw(base_size = 12)


png(height = 4, width = 3, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp6/predicted_growth_mod_past_tile.png")
gg.tile.past.mod
dev.off()


# do the same thing, but just for age structure:
preds_ci_age_struct <- prob %>% group_by(Drought, struct.cohort, DBH.class) %>% summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

#preds_ci_age_struct$PDSI <- unscale(preds_ci_age_struct$Drought, norm.data = DI.scaled)

ggplot(preds_ci_age_struct, aes(Drought, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()

# rename cohort structure numbers to text
cohort.df <- data.frame(cohorts = unique(full.ghcn$struct.cohort)[order(unique(full.ghcn$struct.cohort.code))],
           struct.cohort = 1:4)

preds_ci_age_struct <- merge(cohort.df, preds_ci_age_struct, by = "struct.cohort")
preds_ci_age_struct$cohorts <- factor(preds_ci_age_struct$cohorts, levels =c("Past-Forest", 
                                                                             "Past-Savanna", 
                                                                             "Modern-Forest", 
                                                                             "Modern-Savanna") )

#create tile plots of growth responses over time:
gg.tile.past.mod.cohort <- ggplot(preds_ci_age_struct, aes(Drought, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~cohorts, ncol = 2)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("Palmer Drought Severity Index")+theme_bw(base_size = 12)

png(height = 4, width = 6, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp6/predicted_growth_mod_past_forest_sav_tile.png")
gg.tile.past.mod.cohort
dev.off()



# or we can do the comparisons by hand:
Yp <- data.frame(Yp.samps)
colnames(Yp) <- c(paste0("YP-",test$site))
Yp$num <- rownames(Yp)
Yp.m <- melt(Yp, id.vars=c("num"))


ggplot(Yp.m, aes(value, color = as.factor(Yp.m$variable)))+geom_density(alpha = 0.5)+theme_bw()

library(ggridges)

ggplot(Yp.m, aes(x = value, y = as.factor(DI.index))) + 
  geom_density_ridges()

ggplot(full.ghcn, aes(x = log(RWI), y = as.factor(struct.cohort))) + 
  geom_density_ridges()

# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta2.samps)
 beta2.mn  <- colMeans(beta3.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 


# Plot the Posterior Predictive Density and plug-in
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 ypred.yp <- list()
 diff <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   ypred[[j]]  <- rnorm(np, mu, sigma.mn)
  # lines(density(y),col=2)
   #ypred.yp[[j]] <- Yp.samps[,j]
   #diff[[j]] <- ypred[[j]] - Yp.samps[[j]]
   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)
#diff.df <- do.call(rbind, diff)
#ypred.yp.df <- do.call(rbind, ypred.yp)

Xp$MeanY <- exp(rowMeans(ypred.df))
#Xp$MeanYhat <- exp(rowMeans(ypred.yp.df))# get the means of the posterior to plot the overall effects of 
Xp$struct.cohort <- ifelse(Xp$struct.cohort == 1, "Past-Forest",  
                       ifelse(Xp$struct.cohort == 2, "Modern-Forest",
                               ifelse(Xp$struct.cohort == 3, "Past-Savanna", 
                                       ifelse(Xp$struct.cohort == 4, "Modern-Savanna", NA))))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/site_reg_structure_cohort_re_sp6/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(struct.cohort)))+xlab("Drought Index")+geom_point()+ylab("predicted growth")+stat_smooth()
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/site_reg_structure_cohort_re_sp6/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")+stat_smooth()
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/site_reg_structure_cohort_re_sp6/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
dev.off()

```


Model with cohort RE, SPEI-1 month July and SPEI-6 month July lags
```{r}

site_model_structure_x_cohort_re_SP6_01_06 <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] +  beta3[struct.cohort[i]]*DI.scaled2[i] + beta4[struct.cohort[i]]*DBH.scaled[i] +beta5[struct.cohort[i]]*log_RWI_1[i]  # use Drought index as a scaled variable 


}

# Prediction of test data
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DI.scaled2.p[i] + beta4[struct.cohort.p[i]]*DBH.scaled.p[i]+ beta5[struct.cohort.p[i]]*log_RWI_1.p[i]
  }

# Prediction of probe data for plotting:
  for(i in 1:nprobe){
    Yprobe[i]  ~ dnorm(muprobe[i],inv.var)
    muprobe[i] <- beta1[struct.cohort.probe[i]] + beta2[struct.cohort.probe[i]]*DI.scaled.probe[i] +
 beta3[struct.cohort.probe[i]]*DI.scaled2.probe[i]+beta4[struct.cohort.probe[i]]*DBH.scaled.probe[i]+beta5[struct.cohort.probe[i]]*log_RWI_1.probe[i] 
  }


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
beta4[s] ~ dnorm(mu_beta4[plot[s]], inv_beta4)
beta5[s] ~ dnorm(mu_beta5[plot[s]], inv_beta5)
}



for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)
mu_beta4[j] ~ dnorm(0, 0.5)
mu_beta5[j] ~ dnorm(0, 0.5)
}

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.001, 0.001)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.001, 0.001)
sigma_beta5 <- 1/sqrt(inv_beta5)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)





}"




#save train and testing for later:
saveRDS(train, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/train.rds")
saveRDS(test, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/test.rds")

# generate fake data to predict on:
# we want to plot growth relationship to PDSI for Mod/Past in Sav/Forest in small and large DBH:
library(DMwR)

unscale(vals = 2.9355, norm.data = DBH.scaled) # 80 cm
unscale(vals = 2.305, norm.data = DBH.scaled) # 70 cm
unscale(vals = 1.6745, norm.data = DBH.scaled) # 60 cm
unscale(vals = 1.0441, norm.data = DBH.scaled) # 50 cm
unscale(vals = 0.414, norm.data = DBH.scaled) # 40 cm
unscale(vals = -0.217, norm.data = DBH.scaled) # 30 cm
unscale(vals = -0.8469, norm.data = DBH.scaled) # 20 cm
unscale(vals = -1.4775, norm.data = DBH.scaled) # 10 cm

unscale(vals = -5, norm.data = DI.scaled) # 10 cm


 SPprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 DI.p2 <- round(seq(range(full.ghcn$SP06_6)[1], range(full.ghcn$SP06_6)[2], by = 0.5),3)
 DI.p <- round(seq(range(full.ghcn$SP01_6)[1], range(full.ghcn$SP01_6)[2], by = 0.5),3)
 DBH.p <- c(2.9355, 2.305,1.0441,0.414, -0.217, -0.8469, -1.4775 )# for 40 cm, 30 cm, 20cm, and 10 cm trees respectivly
 log_RWI_1.p <-  round(seq(range(log(train$RWI_1))[1], range(log(train$RWI_1))[2], by = 0.25), 3)
 full.p <- expand.grid(DI.p,DI.p2, DBH.p, log_RWI1.probe = log_RWI_1.p, struct.cohort= 1:4)
 
 



reg.model.site_structure_x_cohort_sp1_sp6 <- jags.model(textConnection(site_model_structure_x_cohort_re_SP6_01_06 ), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$SP01_6, DI.scaled2 = train$SP06_6, DBH.scaled = train$DBH.scaled, struct.cohort = as.numeric(train$struct.cohort.code), log_RWI_1 = log(train$RWI_1), S = unique(train$struct.cohort.code), plot = as.numeric(train$site), ind = unique(train$site),np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$SP01_6, DI.scaled2.p = test$SP06_6, log_RWI_1.p = log(test$RWI_1),
   nprobe = length(full.p$Var1),
   struct.cohort.probe = as.numeric(full.p$struct.cohort), DBH.scaled.probe = full.p$Var3, DI.scaled.probe = full.p$Var1, DI.scaled2.probe = full.p$Var2,  log_RWI_1.probe = full.p$log_RWI1.probe), n.chains = 3, n.adapt = 100)

update(reg.model.site_structure_x_cohort_sp1_sp6, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.site.cohort.re.sp6.sp1 <- coda.samples(reg.model.site_structure_x_cohort_sp1_sp6, 
                     variable.names=c("beta1", "beta2","beta3","beta4","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3", "Yp", "Yprobe"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.site.cohort.re.sp6)
#plot(samp.structure.site.cohort.re.sp6)

#gelman.diag(samp.structure.site.cohort.re.sp6)
#acfplot(samp.structure.site.cohort.re.sp6)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.site.cohort.re.sp6.sp1 [[1]]
 saveRDS(samps, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/samps.rds")
 samps <- readRDS( "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/samps.rds")
 test  <- readRDS("outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/test.rds")
 
 Yp.samps <- samps[,1:length(test$RWI)] 
 Yprobe.samps <-samps [,(length(test$RWI)+ 1):(length(test$RWI)+ length(full.p$Var1))]
 alpha.samps  <- samps[,(length(test$RWI)+length(full.p$Var1)+1):(length(test$RWI)+length(full.p$Var1)+4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+5):(length(test$RWI)+length(full.p$Var1)+8)]
 beta3.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+9):(length(test$RWI)+length(full.p$Var1)+12)]
 beta4.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+13):(length(test$RWI)+length(full.p$Var1)+16)]
 beta5.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+17):(length(test$RWI)+length(full.p$Var1)+20)]
 sigma.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+21)]
 sigma_betas <- samps[,(length(test$RWI)+length(full.p$Var1)+22):(length(test$RWI)+length(full.p$Var1)+26)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "site_reg_structure_cohort_re_sp1_sp6", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)

# get difference between beta2.samps:
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
#hist(sigma_betas[,3], main = "sigma beta3")
dev.off()

library(ggridges)
# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
a$num <- as.numeric(rownames(a))
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab(" random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b2$num <- as.numeric(rownames(b2))
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95),  alpha = 0.5)+theme_black()+ylab("frequency")+xlab("SP01-1 random slopes")

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b3$num <- as.numeric(rownames(b3))
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), alpha = 0.5)+theme_black()+ylab("frequency")+xlab("SP06-6 random slopes")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b4$num <- as.numeric(rownames(b4))
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), alpha = 0.5)+theme_black()+ylab("frequency")+xlab("DBH random slopes")

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b5$num <- as.numeric(rownames(b5))
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), alpha = 0.5)+theme_black()+ylab("frequency")+xlab("Lag-1 random slopes")

library(cowplot)
png(width = 5, height = 8, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/param_marginal_distn_bycohort_struct.png")
cowplot::plot_grid(alpha.mplots, b2.mplots, b3.mplots, b4.mplots, b5.mplots,ncol = 1)
dev.off()


# plot probed values of tree growth predictions:
Yprobe <- data.frame(Yprobe.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
probe.m$RWI <- exp(probe.m$value) 
colnames(probe.m) <- c("num", "Ypred", "RWI")

full.p$num <- 1:length(full.p[,1])
colnames(full.p) <- c("SP01","SP06", "DBH","Log_lag_RWI_1", "struct.cohort", "num")

# summarize by structure + cohort class only:
full.p$num <- as.factor(as.character(full.p$num))
probtest <- dplyr::inner_join(probe.m, full.p, by=c("num"))

prob <- probtest

preds_ci <- prob %>% group_by(num, DBH,SP01, SP06,Log_lag_RWI_1, struct.cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

ggplot(preds_ci, aes(SP01, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~as.factor(DBH))

ggplot(prob, aes(x = Ypred, y = as.factor(SP01))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

ggplot(prob, aes(x = Ypred, y = as.factor(SP06))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

saveRDS(prob, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/full_yprobe_preds.rds")
prob <- readRDS("outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/full_yprobe_preds.rds")

# plot response to sp01-drought for small and large DBH trees in savanna + forest for modern + past
# with sp06 = very droughty, an average prev years growth:

prob_10_60cm_avg <- prob %>% filter(DBH == -0.8469 | DBH ==  2.3050, Log_lag_RWI_1 == 0.284, SP06 == -3.09 | SP06 == -1.09 | SP06 == 2.91 ) 

preds_ci_10 <- prob_10_60cm_avg %>% group_by(DBH, SP01,SP06, struct.cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.05), Ci.high = quantile(RWI, 0.95))
#prob_40cm_avg <- filter(prob, DBH == -0.8469 | DBH == -0.8469, SP06 == 0.41, Log_lag_RWI_1 == 0.03388714)

ggplot(preds_ci_10, aes(SP01, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_grid(~DBH + SP06)

ggplot(preds_ci_10, aes(SP01, meanY, color = as.factor(DBH)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_grid(~struct.cohort+SP06)


# same plots 
prob_10_60cm_avg <- dplyr::filter(prob, DBH == -0.8469) 

preds_ci_10 <- prob_10_60cm_avg %>% group_by( SP01, struct.cohort) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))
#prob_40cm_avg <- filter(prob, DBH == -0.8469 | DBH == -0.8469, SP06 == 0.41, Log_lag_RWI_1 == 0.03388714)


ggplot(preds_ci_10, aes(SP01, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()





# -----------------------------summarize by ageclass only:---------------------------------
prob$ageclass <- ifelse(prob$struct.cohort %in% c("1", "3"),"Past","Modern")
dbh.df <- data.frame(DBH = unique(prob$DBH)[order(unique(prob$DBH))], DBH.class = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm","70cm"))


prob <- merge(dbh.df, prob, by = "DBH")

preds_ci_mod_past <- prob %>% group_by( DBH.class,SP01,SP06, ageclass) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

preds_ci_mod_past$DBH.class <- factor(preds_ci_mod_past$DBH.class, levels = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm", "70cm"))
preds_ci_mod_past$SP06.class <- factor(preds_ci_mod_past$SP06, levels = c("-3.09", "-2.59", "-2.09", "-1.59", "-1.09", "-0.59", "-0.09",  "0.41",  "0.91",  "1.41",  "1.91",  "2.41",  "2.91"))

#preds_ci_mod_past$PDSI <- unscale(preds_ci_mod_past$SP01, norm.data = SP1.scaled)

preds.gg1 <- ggplot(preds_ci_mod_past, aes(SP01, meanY, color = as.factor(ageclass)))+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+stat_smooth()+facet_grid(rows = vars(SP06.class), cols = vars(DBH.class))+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

preds.gg <- ggplot(preds_ci_mod_past, aes(SP06, meanY, color = as.factor(ageclass)))+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+stat_smooth()+facet_grid(rows = vars(SP01), cols = vars(DBH.class))+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

png(height = 10, width = 10, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/predicted_growth_mod_past_SP01_CI.png")
preds.gg
dev.off()


preds_ci_mod_past$ageclass <- factor(preds_ci_mod_past$ageclass, levels = c("Past", "Modern"))
gg.tile.past.mod2 <- ggplot(preds_ci_mod_past, aes(SP06, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~ageclass, ncol = 1)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SPEI - 6 month")+theme_bw(base_size = 12)

gg.tile.past.mod2 <- ggplot(preds_ci_mod_past, aes(SP06, DBH.class, fill = meanY))+geom_raster()+facet_grid(rows = vars(SP01),cols = vars(ageclass))+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SPEI - 6 month")+theme_bw(base_size = 12)


png(height = 4, width = 3, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/predicted_growth_mod_past_tile.png")
gg.tile.past.mod
dev.off()


# do the same thing, but just for age structure:
preds_ci_age_struct <- prob %>% group_by(SP01,SP06, struct.cohort, DBH.class) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

#preds_ci_age_struct$PDSI <- unscale(preds_ci_age_struct$Drought, norm.data = DI.scaled)

ggplot(preds_ci_age_struct, aes(SP01, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~SP06)

# rename cohort structure numbers to text
cohort.df <- data.frame(cohorts = unique(full.ghcn$struct.cohort)[order(unique(full.ghcn$struct.cohort.code))],
           struct.cohort = 1:4)

preds_ci_age_struct <- merge(cohort.df, preds_ci_age_struct, by = "struct.cohort")
preds_ci_age_struct$cohorts <- factor(preds_ci_age_struct$cohorts, levels =c("Past-Forest", 
                                                                             "Past-Savanna", 
                                                                             "Modern-Forest", 
                                                                             "Modern-Savanna") )

#create tile plots of growth responses over time:
gg.tile.past.mod.cohort <- ggplot(preds_ci_age_struct, aes(SP06, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~cohorts, ncol = 2)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SP06")+theme_bw(base_size = 12)

gg.tile.past.mod.cohort <- ggplot(preds_ci_age_struct, aes(SP01, DBH.class, fill = meanY))+geom_raster()+facet_grid(cols = vars(cohorts), rows = vars(SP06))+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SP01")+theme_bw(base_size = 12)

png(height = 8, width = 10, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/predicted_growth_mod_past_forest_sav_tile_sp6.png")
gg.tile.past.mod.cohort
dev.off()

```

Model with cohort RE, SPEI-6 month july, june, aug droughts and June, july aug temperature + previous year RWI:
```{r}

site_model_structure_x_cohort_re_SP6_06_prevRWI <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] +  beta3[struct.cohort[i]]*DI.scaled2[i] + beta4[struct.cohort[i]]*DBH.scaled[i]+ beta5[struct.cohort[i]]*log_RWI_1[i]   # use Drought index as a scaled variable 


}

# Prediction of test data
  for(i in 1:np){
    Yp[i]  ~ dnorm(mup[i],inv.var)
    mup[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DI.scaled2.p[i] + beta4[struct.cohort.p[i]]*DBH.scaled.p[i]+ beta5[struct.cohort.p[i]]*log_RWI_1.p[i]
  }

# Prediction of probe data for plotting:
  for(i in 1:nprobe){
    Yprobe[i]  ~ dnorm(muprobe[i],inv.var)
    muprobe[i] <- beta1[struct.cohort.probe[i]] + beta2[struct.cohort.probe[i]]*DI.scaled.probe[i] +
 beta3[struct.cohort.probe[i]]*DI.scaled2.probe[i]+beta4[struct.cohort.probe[i]]*DBH.scaled.probe[i]+beta5[struct.cohort.probe[i]]*log_RWI_1.probe[i] 
  }


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
beta4[s] ~ dnorm(mu_beta4[plot[s]], inv_beta4)
beta5[s] ~ dnorm(mu_beta5[plot[s]], inv_beta5)
}


for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)
mu_beta4[j] ~ dnorm(0, 0.5)
mu_beta5[j] ~ dnorm(0, 0.5)
}

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.001, 0.001)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.001, 0.001)
sigma_beta5 <- 1/sqrt(inv_beta5)

# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)


}"





# save these for use later:
saveRDS(train, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/train.rds")
saveRDS(test, "outputs/growth_model/site_reg_structure_cohort_re_sp1_sp6/test.rds")

# generate fake data to predict on:
# we want to plot growth relationship to PDSI for Mod/Past in Sav/Forest in small and large DBH:
library(DMwR)

unscale(vals = 2.9355, norm.data = DBH.scaled) # 80 cm
unscale(vals = 2.305, norm.data = DBH.scaled) # 70 cm
unscale(vals = 1.6745, norm.data = DBH.scaled) # 60 cm
unscale(vals = 1.0441, norm.data = DBH.scaled) # 50 cm
unscale(vals = 0.414, norm.data = DBH.scaled) # 40 cm
unscale(vals = -0.217, norm.data = DBH.scaled) # 30 cm
unscale(vals = -0.8469, norm.data = DBH.scaled) # 20 cm
unscale(vals = -1.4775, norm.data = DBH.scaled) # 10 cm


 SPprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 DI.p2 <- seq(range(full.ghcn$SP06_6)[1], range(full.ghcn$SP06_6)[2], by = 0.5)
 DI.p <- seq(range(full.ghcn$SP01_6)[1], range(full.ghcn$SP01_6)[2], by = 0.5)
 DBH.p <- c(2.9355, 2.305,1.0441,0.414, -0.217, -0.8469, -1.4775 )# for 40 cm, 30 cm, 20cm, and 10 cm trees respectivly
 log_RWI_1.p <-  seq(range(log(train$RWI_1))[1], range(log(train$RWI_1))[2], by = 0.25)
 full.p <- expand.grid(DI.p,DI.p2, DBH.p, log_RWI1.probe = log_RWI_1.p, struct.cohort= 1:4)
 
 



reg.model.site_structure_x_cohort_sp1_sp6 <- jags.model(textConnection(site_model_structure_x_cohort_re_SP6_06_prevRWI ), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), DI.scaled = train$SP01_6, DI.scaled2 = train$SP06_6, DBH.scaled = train$DBH.scaled, log_RWI_1 = log(train$RWI_1), struct.cohort = as.numeric(train$struct.cohort.code), S = unique(train$struct.cohort.code), plot = as.numeric(train$site), ind = unique(train$site),np = length(test$DBH.scaled),
   struct.cohort.p = as.numeric(test$struct.cohort.code), log_RWI_1.p = log(test$RWI_1),DBH.scaled.p = test$DBH.scaled, DI.scaled.p = test$SP01_6, DI.scaled2.p = test$SP06_6,
   nprobe = length(full.p$Var1),
   struct.cohort.probe = as.numeric(full.p$struct.cohort), DBH.scaled.probe = full.p$Var3, DI.scaled.probe = full.p$Var1, DI.scaled2.probe = full.p$Var2, log_RWI_1.probe = full.p$log_RWI1.probe
   ), n.chains = 3, n.adapt = 100)

update(reg.model.site_structure_x_cohort_sp1_sp6, 1000); # Burnin for 1000 samples to start, then go higher later


samp.structure.site.cohort.re.sp6.sp1 <- coda.samples(reg.model.site_structure_x_cohort_sp1_sp6, 
                     variable.names=c("beta1", "beta2","beta3","beta4","beta5","sigma", "sigma_beta1", "sigma_beta2","sigma_beta3","sigma_beta4", "sigma_beta5","Yp", "Yprobe"), 
                    n.chains = 3, n.iter=20000, thin = 15)

#summary(samp.structure.site.cohort.re.sp6)
#plot(samp.structure.site.cohort.re.sp6)

#gelman.diag(samp.structure.site.cohort.re.sp6)
#acfplot(samp.structure.site.cohort.re.sp6)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp.structure.site.cohort.re.sp6.sp1 [[1]]
 saveRDS(samps, "outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/samps.rds")
samps  <- readRDS("outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/sampsrds")
 
 Yp.samps <- samps[,1:length(test$RWI)] 
 Yprobe.samps <-samps [,(length(test$RWI)+ 1):(length(test$RWI)+ length(full.p$Var1))]
 alpha.samps  <- samps[,(length(test$RWI)+length(full.p$Var1)+1):(length(test$RWI)+length(full.p$Var1)+4)]# one alpha for each of 4 cohort-strcuture groups
 beta2.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+5):(length(test$RWI)+length(full.p$Var1)+8)]
 beta3.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+9):(length(test$RWI)+length(full.p$Var1)+12)]
 beta4.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+13):(length(test$RWI)+length(full.p$Var1)+16)]
  beta4.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+17):(length(test$RWI)+length(full.p$Var1)+20)]
 sigma.samps <- samps[,(length(test$RWI)+length(full.p$Var1)+21)]
 sigma_betas <- samps[,(length(test$RWI)+length(full.p$Var1)+22):(length(test$RWI)+length(full.p$Var1)+26)]

 
# plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "site_reg_structure_cohort_re_sp06_sp01_lag", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)


# get difference between beta2.samps:
oneminustwo <- beta2.samps[,1] - beta2.samps[,2]
oneminusthree <- beta2.samps[,1] - beta2.samps[,3]
oneminusfour <- beta2.samps[,1] - beta2.samps[,4]
twominusthree <- beta2.samps[,2] - beta2.samps[,3]
twominusfour <- beta2.samps[,2] - beta2.samps[,4]
threeminusfour <- beta2.samps[,3] - beta2.samps[,4]
# calculate MSPE
# get posterior predictive density

# plot marginal distributions of each parameter:
png("outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Forest")
hist(alpha.samps[,2], main = "alpha Modern-Forest")
hist(alpha.samps[,3],  main = "alpha Past-Savanna ")
hist(alpha.samps[,4],  main = "alpha Modern-Savanna")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Forest")
hist(beta2.samps[,2], main = "beta2 Modern-Forest")
hist(beta2.samps[,3],  main = "beta2 Past-Savanna")
hist(beta2.samps[,4],  main = "beta2 Modern-Savanna")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Forest")
hist(beta3.samps[,2], main = "beta3 Modern-Forest")
hist(beta3.samps[,3],  main = "beta3 Past-Savanna")
hist(beta3.samps[,4],  main = "beta3 Modern-Savanna")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()

png("outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta4.samps[,1], main = "beta4 Past-Forest")
hist(beta4.samps[,2], main = "beta4 Modern-Forest")
hist(beta4.samps[,3],  main = "beta4 Past-Savanna")
hist(beta4.samps[,4],  main = "beta4 Modern-Savanna")
#hist(sigma_betas[,3], main = "sigma beta3")
dev.off()

library(ggridges)
# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
a$num <- as.numeric(rownames(a))
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), bandwidth = 0.005, alpha = 0.5)+theme_black()+ylab("frequency")+xlab(" random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b2$num <- as.numeric(rownames(b2))
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95),  alpha = 0.5)+theme_black()+ylab("frequency")+xlab("SP01-1 random slopes")

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b3$num <- as.numeric(rownames(b3))
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), alpha = 0.5)+theme_black()+ylab("frequency")+xlab("SP06-6 random slopes")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))
b4$num <- as.numeric(rownames(b4))
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value,1, fill = variable))+stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.05, 0.95), alpha = 0.5)+theme_black()+ylab("frequency")+xlab("DBH random slopes")


library(cowplot)
png(width = 5, height = 8, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/param_marginal_distn_bycohort_struct.png")
cowplot::plot_grid(alpha.mplots, b2.mplots, b3.mplots, b4.mplots,ncol = 1)
dev.off()


# plot probed values of tree growth predictions:
Yprobe <- data.frame(Yprobe.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
probe.m$RWI <- exp(probe.m$value) 
colnames(probe.m) <- c("num", "Ypred", "RWI")

full.p$num <- 1:length(full.p[,1])
colnames(full.p) <- c("SP01","SP06", "DBH","log_RWI.probe", "struct.cohort", "num")

# summarize by structure + cohort class only:
prob <- merge(probe.m, full.p, by = "num")
preds_ci <- prob %>% group_by(num, DBH,SP01, SP06, struct.cohort) %>% dplyr::summarise(meanY = mean(exp(RWI)),
                                                                            Ci.low = quantile(exp(RWI), 0.025), Ci.high = quantile(RWI, 0.975))

ggplot(preds_ci, aes(SP01, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~as.factor(DBH))

ggplot(prob, aes(x = Ypred, y = as.factor(SP01))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

ggplot(prob, aes(x = Ypred, y = as.factor(SP06))) + 
  geom_density_ridges()+facet_grid(~ DBH)+coord_flip()

# summarize by ageclass only:
prob$ageclass <- ifelse(prob$struct.cohort %in% c("1", "3"),"Past","Modern")
dbh.df <- data.frame(DBH = unique(prob$DBH)[order(unique(prob$DBH))], DBH.class = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm","70cm"))


prob <- merge(dbh.df, prob, by = "DBH")

preds_ci_mod_past <- prob %>% group_by( DBH.class,SP01,SP06, ageclass) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

preds_ci_mod_past$DBH.class <- factor(preds_ci_mod_past$DBH.class, levels = c("10cm", "20cm", "30cm", "40cm", "50cm", "60cm", "70cm"))
preds_ci_mod_past$SP06.class <- factor(preds_ci_mod_past$SP06, levels = c("-3.09", "-2.59", "-2.09", "-1.59", "-1.09", "-0.59", "-0.09",  "0.41",  "0.91",  "1.41",  "1.91",  "2.41",  "2.91"))

#preds_ci_mod_past$PDSI <- unscale(preds_ci_mod_past$SP01, norm.data = SP1.scaled)

preds.gg1 <- ggplot(preds_ci_mod_past, aes(SP01, meanY, color = as.factor(ageclass)))+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+stat_smooth()+facet_grid(rows = vars(SP06.class), cols = vars(DBH.class))+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

preds.gg <- ggplot(preds_ci_mod_past, aes(SP06, meanY, color = as.factor(ageclass)))+
  geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = as.factor(ageclass)), alpha = 0.1, linetype = "dashed")+scale_color_manual (values = c("Modern" = "red", "Past" = "blue"))+stat_smooth()+facet_grid(rows = vars(SP01), cols = vars(DBH.class))+theme(legend.title = element_blank())+ylab("Predicted Ring Width")
 

png(height = 10, width = 10, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/predicted_growth_mod_past_SP01_CI.png")
preds.gg
dev.off()


preds_ci_mod_past$ageclass <- factor(preds_ci_mod_past$ageclass, levels = c("Past", "Modern"))
gg.tile.past.mod2 <- ggplot(preds_ci_mod_past, aes(SP06, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~ageclass, ncol = 1)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SPEI - 6 month")+theme_bw(base_size = 12)

gg.tile.past.mod2 <- ggplot(preds_ci_mod_past, aes(SP06, DBH.class, fill = meanY))+geom_raster()+facet_grid(rows = vars(SP01),cols = vars(ageclass))+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SPEI - 6 month")+theme_bw(base_size = 12)


png(height = 4, width = 3, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/predicted_growth_mod_past_tile.png")
gg.tile.past.mod
dev.off()


# do the same thing, but just for age structure:
preds_ci_age_struct <- prob %>% group_by(SP01,SP06, struct.cohort, DBH.class) %>% dplyr::summarise(meanY = mean(RWI),
                                                                            Ci.low = quantile(RWI, 0.025), Ci.high = quantile(RWI, 0.975))

#preds_ci_age_struct$PDSI <- unscale(preds_ci_age_struct$Drought, norm.data = DI.scaled)

ggplot(preds_ci_age_struct, aes(SP01, meanY, color = as.factor(struct.cohort)))+geom_point()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high), alpha = 0.1, fill = "grey60", linetype = "dashed")+stat_smooth()+facet_wrap(~SP06)

# rename cohort structure numbers to text
cohort.df <- data.frame(cohorts = unique(full.ghcn$struct.cohort)[order(unique(full.ghcn$struct.cohort.code))],
           struct.cohort = 1:4)

preds_ci_age_struct <- merge(cohort.df, preds_ci_age_struct, by = "struct.cohort")
preds_ci_age_struct$cohorts <- factor(preds_ci_age_struct$cohorts, levels =c("Past-Forest", 
                                                                             "Past-Savanna", 
                                                                             "Modern-Forest", 
                                                                             "Modern-Savanna") )

#create tile plots of growth responses over time:
gg.tile.past.mod.cohort <- ggplot(preds_ci_age_struct, aes(SP06, DBH.class, fill = meanY))+geom_raster()+facet_wrap(~cohorts, ncol = 2)+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SP06")+theme_bw(base_size = 12)

gg.tile.past.mod.cohort <- ggplot(preds_ci_age_struct, aes(SP01, DBH.class, fill = meanY))+geom_raster()+facet_grid(cols = vars(cohorts), rows = vars(SP06))+scale_fill_distiller(palette = "BrBG", direction = 1, name = "Tree \nGrowth")+ylab("Tree diameter")+xlab("SP01")+theme_bw(base_size = 12)

png(height = 8, width = 10, units = "in", res = 300, "outputs/growth_model/site_reg_structure_cohort_re_sp06_sp01_lag/predicted_growth_mod_past_forest_sav_tile_sp6.png")
gg.tile.past.mod.cohort
dev.off()

```

# model for cohort effects with summer VPD instead of PDSI
```{r}

cohort_model_site_VPD_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[cohort[i]] + beta2[cohort[i]]*VPD.scaled[i] + beta3[cohort[i]]*DBH.scaled[i]+ beta4[cohort[i]]*log_RWI_1[i]  # use Drought index as a scaled variable 
}



# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
beta4[s] ~ dnorm(mu_beta4[plot[s]], inv_beta4)
}


for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)
mu_beta4[j] ~ dnorm(0, 0.5)
}

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.001, 0.001)
sigma_beta4 <- 1/sqrt(inv_beta4)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)


for(i in 1:np){
# process model
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1[cohort.p[i]] + beta2[cohort.p[i]]*VPD.scaled.p[i] + beta3[cohort.p[i]]*DBH.scaled.p[i] + beta4[cohort.p[i]]*log_RWI_1.p[i]  # use Drought index as a scaled variable 
}

}"

cohort.model.VPD.re <- jags.model(textConnection(cohort_model_site_VPD_re ), 
                    data = list(Y=log(train$RWI), n=length(train$RWI), VPD.scaled = train$jja.VPDmax.scaled, DBH.scaled = train$DBH.scaled, log_RWI_1 = log(train$RWI_1), cohort = as.numeric(train$ageclass), S = unique(train$ageclass),
                    plot = as.numeric(train$site), ind = unique(train$site), np = length(test$DBH.scaled),  VPD.scaled.p = test$jja.VPDmax.scaled, DBH.scaled.p = test$DBH.scaled, log_RWI_1.p = log(test$RWI_1), cohort.p = as.numeric(test$ageclass), SP = unique(test$ageclass),
                    plot.p = as.numeric(test$site), ind.p = unique(test$site)), n.chains = 3, n.adapt = 100)

update(cohort.model.VPD.re , 2000); # Burnin for 1000 samples to start, then go higher later

samp <- coda.samples(cohort.model.VPD.re , 
                     variable.names=c("beta1", "beta2","beta3","beta4","sigma", "sigma_beta1", "sigma_beta2", "sigma_beta3","sigma_beta4", "mu_beta1", "mu_beta2", "mu_beta3", "mu_beta4","Yp"), 
                    n.chains = 3, n.iter=2000, thin = 10)

summary(samp)
traceplot(samp)
gelman.diag(samp)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp[[1]]
 saveRDS(samps, "outputs/growth_model/basic_reg_cohort_site_VPD_re/samps.rds")
 Yp.samps    <- samps[,1:length(test$RWI)] 
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 alpha.samps  <- samps[,(length(test$RWI)+1):(length(test$RWI)+2)]
 beta2.samps <- samps[,(length(test$RWI)+3):(length(test$RWI)+4)]
 beta3.samps <- samps[,(length(test$RWI)+5):(length(test$RWI)+6)]
 beta4.samps <- samps[,(length(test$RWI)+7):(length(test$RWI)+8)]
 mu_beta1.samps <- samps[,(length(test$RWI)+9):(length(test$RWI)+10)]
 mu_beta2.samps <- samps[,(length(test$RWI)+11):(length(test$RWI)+12)]
 mu_beta3.samps <- samps[,(length(test$RWI)+13):(length(test$RWI)+14)]
 mu_beta4.samps <- samps[,(length(test$RWI)+15):(length(test$RWI)+16)]
 sigma.samps <- samps[,(length(test$RWI)+17)]
 sigma_betas <- samps[,(length(test$RWI)+18):(length(test$RWI)+21)]

 
 
 # plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(Yp.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(exp(value)),
                                                  ci.hi = quantile(exp(value),0.975),
                                                 ci.lo = quantile(exp(value),0.025))
Yp.summary$Observed <- test$RWI

pred.obs <- summary(lm(colMeans(exp(Yp.samps))~ test$RWI))

p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+ylim(0, 8)+xlim(0,8)+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note poor model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/basic_reg_cohort_site_VPD_re/pred_vs_obs.png")
p.o.plot
dev.off()


# calculate MSE & BIAS:

MSE1   <- mean((colMeans(exp(Yp.samps))-test$RWI)^2)
BIAS1  <- mean(colMeans(exp(Yp.samps))-test$RWI)

# write model summary output to a file!

model.summary <- data.frame(model = "basic_reg_cohort_site_VPD_re", 
           MSE = MSE1, 
           BIAS = BIAS1, 
           Rsq = pred.obs$r.squared)

write.csv(model.summary, paste0("outputs/growth_model/model_summary/", model.summary$model, "_summary.csv"), row.names = FALSE)


 
png("outputs/growth_model/basic_reg_cohort_site_VPD_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past")
hist(alpha.samps[,2], main = "alpha Modern")
#hist(alpha.samps[,3],  main = "alpha Past-Forest")
#hist(alpha.samps[,4],  main = "alpha Modern-Forest")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/basic_reg_cohort_site_VPD_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Savanna")
hist(beta2.samps[,2], main = "beta2 Modern-Savanna")
#hist(beta2.samps[,3],  main = "beta2 Past-Forest")
#hist(beta2.samps[,4],  main = "beta2 Modern-Forest")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()





png("outputs/growth_model/basic_reg_cohort_site_VPD_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Savanna")
hist(beta3.samps[,2], main = "beta3 Modern-Savanna")
#hist(beta3.samps[,3],  main = "beta3 Past-Forest")
#hist(beta3.samps[,4],  main = "beta3 Modern-Forest")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_cohort_site_VPD_re/marginal_mu_beta2s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta3.samps))){
  hist(mu_beta2.samps[,i], main = paste(colnames(mu_beta2.samps)[i]))
}
dev.off()


png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_cohort_site_VPD_re/marginal_mu_beta3s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta3.samps))){
  hist(mu_beta3.samps[,i], main = paste(colnames(mu_beta3.samps)[i]))
}
dev.off()

png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_cohort_site_VPD_re/marginal_mu_beta1s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta1.samps))){
  hist(mu_beta1.samps[,i], main = paste(colnames(mu_beta1.samps)[i]))
}
dev.off()

# plot predicted vs. observed:
png("outputs/growth_model/basic_reg_cohort_site_VPD_re/pred_vs_obs.png")
plot(colMeans(exp(Yp.samps)), test$RWI) 
abline(a = 0, b = 1, col = "red")
dev.off()



# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-", c("Modern", "Past")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Random intercepts")+theme_black()


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0("beta2-",c("Modern", "Past")))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("VPD Index slope")+theme_black()


b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c("Modern", "Past")))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("DBH slope")+theme_black()

library(cowplot)
png(width = 5, height = 6, units = "in", res = 300, "outputs/growth_model/basic_reg_cohort_site_VPD_re/param_marginal_distn_bycohort.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()

# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(alpha.samps)
 beta2.mn  <- colMeans(beta2.samps)
 beta3.mn  <- colMeans(beta3.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 
 #mu_beta1.samps <- colMeans(mu_beta1.samps) 
 #mu_beta2.samps <- colMeans(mu_beta2.samps) 
 #mu_beta3.samps <- colMeans(mu_beta3.samps) 


# get posterior predictions:
 DIprobe <- seq(range(full.ghcn$jja.VPDmax.scaled)[1], range(full.ghcn$jja.VPDmax.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  cohort= 1:2, site = as.numeric(unique(full.ghcn$site)))
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:



 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 
 
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

        
        alpha1.mn <- rnorm(1000, mu_beta1.samps[Xp[j,4]], mean(sigma_betas[,1]) ) # check the sigma betas
        beta2.mn <- rnorm(1000, mu_beta2.samps[Xp[j,4]], mean(sigma_betas[,2]) ) # check the sigma betas
        beta3.mn <- rnorm(1000, mu_beta3.samps[Xp[j,3]], mean(sigma_betas[,3]) ) # check the sigma betas
       
   mu <- alpha1.mn + beta2.mn*Xp[j,1] + beta2.mn*Xp[j,2]   # use
   
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   
   ypred[[j]]  <- mu
  # lines(density(y),col=2)
   
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)


Xp$MeanY <- rowMeans(exp(ypred.df))

Xp$cohort <- ifelse(Xp$cohort == 2, "Past",  
                       ifelse(Xp$cohort == 1, "Modern",NA))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_cohort_site_VPD_re/Ypred_by_VPD_struct_x_cohort.png")
ggplot(Xp, aes(Var1, MeanY, color = as.factor(site), shape = as.factor(cohort)))+geom_point()+xlab("VPD Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_VPD_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_VPD_re/Ypred_by_VPD_DBH_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(cohort))
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_VPD_re/Ypred_by_VPD_DBH_site.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(site))
dev.off()


png(height = 10, width = 10, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_DBH_site_cohort.png")
ggplot(Xp[!Xp$site %in% "10",], aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(site) + as.factor(cohort))
dev.off()

```

# cohort model for only comparable drought years:
# model for cohort effects and site level effects, heirarchically:
```{r}
cohort_model_dry_site_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1[cohort[i]] + beta2[cohort[i]]*DI.scaled[i] + beta3[cohort[i]]*DBH.scaled[i]   # use Drought index as a scaled variable 
}



# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
beta1[s] ~ dnorm(mu_beta1[plot[s]], inv_beta1)
beta2[s] ~ dnorm(mu_beta2[plot[s]], inv_beta2)
beta3[s] ~ dnorm(mu_beta3[plot[s]], inv_beta3)
}


for(j in 1:length(ind)){
# use normal hyperpriors for each hyperparamters 
mu_beta1[j] ~ dnorm(0, 0.5)
mu_beta2[j] ~ dnorm(0, 0.5)
mu_beta3[j] ~ dnorm(0, 0.5)

}

inv_beta1   ~ dgamma(0.001, 0.001)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.001, 0.001)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.001, 0.001)
sigma_beta3 <- 1/sqrt(inv_beta3)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.0001, 0.0001)
sigma     <- 1/sqrt(inv.var)

# predictions for the model:
for(i in 1:np){
# process model
Yp[i]   ~ dnorm(gfuncp[i], inv.var) # where Yi is already log transformed

# function g()
gfuncp[i] <- beta1[cohort.p[i]] + beta2[cohort.p[i]]*DI.scaled.p[i] + beta3[cohort.p[i]]*DBH.scaled.p[i]   # use Drought index as a scaled variable 
}


}"



# save training and testing for later:
saveRDS(train, "outputs/growth_model/basic_reg_dry_cohort_site_re/train.rds")
saveRDS(test, "outputs/growth_model/basic_reg_dry_cohort_site_re/test.rds")

cohort.model.dry.re <- jags.model(textConnection(cohort_model_dry_site_re), 
                    data = list(Y=log(dry.yrs$RWI), n=length(dry.yrs$RWI), DI.scaled = dry.yrs$DI.scaled, DBH.scaled = dry.yrs$DBH.scaled, cohort = as.numeric(dry.yrs$ageclass), S = unique(dry.yrs$ageclass),
                    plot = as.numeric(dry.yrs$site), ind = unique(dry.yrs$site),  np=length(test$RWI), DI.scaled.p = test$DI.scaled, DBH.scaled.p = test$DBH.scaled, cohort.p = as.numeric(test$ageclass), SP = unique(test$ageclass),
                    plot.p = as.numeric(test$site), ind.p = unique(test$site)), n.chains = 3, n.adapt = 100)

update(cohort.model.dry.re, 2000); # Burnin for 1000 samples to start, then go higher later

samp <- coda.samples(cohort.model.dry.re, 
                     variable.names=c("beta1", "beta2","beta3","sigma", "sigma_beta1", "sigma_beta2", "sigma_beta3", "mu_beta1", "mu_beta2", "mu_beta3","Yp"), 
                    n.chains = 3, n.iter=10000, thin = 10)

summary(samp)
traceplot(samp)
gelman.diag(samp)



#Extract the samples for each parameter for a basic exploration of effects

 samps       <- samp[[1]]
 
 saveRDS(samps, "outputs/growth_model/basic_reg_dry_cohort_site_re/samps_full.rds")
 samps <-  readRDS( "outputs/growth_model/basic_reg_dry_cohort_site_re/samps_full.rds")
 Yp.samps    <- samps[,1:length(test$RWI)] 
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 alpha.samps  <- samps[,(length(test$RWI)+1):(length(test$RWI)+2)]
 beta2.samps <- samps[,(length(test$RWI)+3):(length(test$RWI)+4)]
 beta3.samps <- samps[,(length(test$RWI)+5):(length(test$RWI)+6)]
 mu_beta1.samps <- samps[,(length(test$RWI)+7):(length(test$RWI)+20)]
 mu_beta2.samps <- samps[,(length(test$RWI)+21):(length(test$RWI)+34)]
 mu_beta3.samps <- samps[,(length(test$RWI)+35):(length(test$RWI)+48)]
 sigma.samps <- samps[,(length(test$RWI)+49)]
 sigma_betas <- samps[,(length(test$RWI)+50):(length(test$RWI)+52)]

 
png("outputs/growth_model/basic_reg_dry_cohort_site_re/pred_vs_obs.png")
plot(colMeans(exp(Yp.samps)), test$RWI) 
abline(a = 0, b = 1, col = "red")
dev.off()

residual <- colMeans(exp(Yp.samps)) - test$RWI

hist(residual)


png("outputs/growth_model/basic_reg_dry_cohort_site_re/marginal_alphas.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past")
hist(alpha.samps[,2], main = "alpha Modern")
#hist(alpha.samps[,3],  main = "alpha Past-Forest")
#hist(alpha.samps[,4],  main = "alpha Modern-Forest")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/basic_reg_dry_cohort_site_re/marginal_beta1s.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Savanna")
hist(beta2.samps[,2], main = "beta2 Modern-Savanna")
#hist(beta2.samps[,3],  main = "beta2 Past-Forest")
#hist(beta2.samps[,4],  main = "beta2 Modern-Forest")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()





png("outputs/growth_model/basic_reg_dry_cohort_site_re/marginal_beta2s.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Savanna")
hist(beta3.samps[,2], main = "beta3 Modern-Savanna")
#hist(beta3.samps[,3],  main = "beta3 Past-Forest")
#hist(beta3.samps[,4],  main = "beta3 Modern-Forest")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_dry_cohort_site_re/marginal_mu_beta2s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta2.samps))){
  hist(mu_beta2.samps[,i], main = paste(colnames(mu_beta2.samps)[i]))
}
dev.off()


png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_dry_cohort_site_re/marginal_mu_beta3s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta3.samps))){
  hist(mu_beta3.samps[,i], main = paste(colnames(mu_beta3.samps)[i]))
}
dev.off()

png(height = 10, width = 10, units = "in", res = 300,"outputs/growth_model/basic_reg_dry_cohort_site_re/marginal_mu_beta1s.png")
par(mfrow=c(4,4))
for(i in 1:length(colnames(mu_beta1.samps))){
  hist(mu_beta1.samps[,i], main = paste(colnames(mu_beta1.samps)[i]))
}
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-", c("Modern", "Past")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+xlab("Random intercepts")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c("Modern", "Past")))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <-ggplot(b2.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.0075)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 18)+scale_fill_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))

b2.mean <- apply(as.matrix(b2[,1:2]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:2]), 2, function(x) quantile(x, probs = c(0.05)))
b2.upper <- apply(as.matrix(b2[,1:2]), 2, function(x) quantile(x, probs = c(0.95)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)
plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c("Past", "Modern"))
b2.dots <- ggplot(plot.dat.b2, aes(x = b2.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+xlim(0 , 0.25)+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 5, width = 8, units = "in", res = 300, "outputs/growth_model/basic_reg_dry_cohort_site_re/drougt_beta_marginal_distn_bycohort.png")
plot_grid(b2.dots+xlim(0.05 , 0.3), b2.mplots+coord_flip()+xlim(0.05 , 0.3)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))
dev.off()

# difference between betas:
beta2.diff <- beta2.samps[,1] - beta2.samps[,2]

b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c("Modern", "Past")))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+xlab("DBH slope")



library(cowplot)
png(width = 5, height = 10, units = "in", res = 300, "outputs/growth_model/basic_reg_dry_cohort_site_re/param_marginal_distn_bycohort.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, ncol = 1)
dev.off()

# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 beta3.mn  <- colMeans(beta3.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 
 #mu_beta1.samps <- colMeans(mu_beta1.samps) 
 #mu_beta2.samps <- colMeans(mu_beta2.samps) 
 #mu_beta3.samps <- colMeans(mu_beta3.samps) 


# get posterior predictions:
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  cohort= 1:2, site = as.numeric(unique(full.ghcn$site)))
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:



 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()
 
 
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

        
        alpha1.mn <- rnorm(1000, mu_beta1.samps[Xp[j,4]], mean(sigma_betas[,1]) ) # check the sigma betas
        beta2.mn <- rnorm(1000, mu_beta2.samps[Xp[j,4]], mean(sigma_betas[,2]) ) # check the sigma betas
        beta3.mn <- rnorm(1000, mu_beta3.samps[Xp[j,3]], mean(sigma_betas[,3]) ) # check the sigma betas
       
   mu <- alpha1.mn + beta2.mn*Xp[j,1] + beta2.mn*Xp[j,2]   # use
   
   #mu <- alpha1.mn+sum(Xp[j,1]*beta1.mn, Xp[j,2]*beta2.mn)
   
   ypred[[j]]  <- mu
  # lines(density(y),col=2)
   
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)


Xp$MeanY <- exp(rowMeans(ypred.df))

Xp$cohort <- ifelse(Xp$cohort == 2, "Past",  
                       ifelse(Xp$cohort == 1, "Modern",NA))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1, MeanY, color = as.factor(site), shape = as.factor(cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_DBH_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(cohort))
dev.off()

png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_DBH_site.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(site))
dev.off()


png(height = 10, width = 10, units = "in", res = 200,"outputs/growth_model/basic_reg_cohort_site_re/Ypred_by_drought_DBH_site_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~ as.factor(site) + as.factor(cohort))
dev.off()

```







# >>>>>>>>>>>>>>>>>>>>>> Stable isotope results <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# intercept only model (mean for d13C):
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
d13C_intercept_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for iWUE:
d13[i]   ~ dnorm(d13func[i], inv.var) # where Yi is already log transformed

# function g()
d13func[i] <- beta1[struct.cohort[i]]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
}



# use normal hyperpriors for each hyperparamters 

mu_beta1 ~ dnorm(0, 0.1)


inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)



# Non-informative Prior for the inverse population variances

inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


# Predict test data:
for(i in 1:np){
# process model for 13:
d13.p[i]   ~ dnorm(d13func.p[i], inv.var) # where Yi is already log transformed

# function g()
d13func.p[i] <- beta1[struct.cohort.p[i]]

}


}"

test.iso <- test.iso[!is.na(test.iso$Cor.d13C.suess),]
train.iso <- train.iso[!is.na(train.iso$Cor.d13C.suess),]

d13_mean <- jags.model(textConnection(d13C_intercept_re), 
                    data = list(d13 = train.iso[!train.iso$site %in% "BON",]$Cor.d13C.suess, n=length(train.iso[!train.iso$site %in% "BON",]$iWUE), struct.cohort = as.numeric(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), SF = unique(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), struct.cohort.p =as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code), np = length(as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code)) ), n.chains = 3, n.adapt = 100)

update(d13_mean, 1000); # Burnin for 1000 samples to start, then go higher later


d13.mean.re <- coda.samples(d13_mean, 
                     variable.names=c("beta1", "mu_beta1", "d13.p"), 
                    n.chains = 3, n.iter = 20000, thin = 15)

#summary(d13.mean.re )
#plot(d13.mean.re )

#gelman.diag(d13.mean.re  )
#acfplot(d13.mean.re )

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- d13.mean.re [[1]]
 saveRDS(samps, "outputs/growth_model/d13C_intercept_mode/samps.d13_noBON.rds")
 saveRDS(samps, "outputs/growth_model/d13C_intercept_mode/train_iso_noBON.rds")
saveRDS(samps, "outputs/growth_model/d13C_intercept_mode/test_iso_noBON.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1:4]
 d13p.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]


 #------------------ plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(d13p.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess

pred.obs <- summary(lm(colMeans(Yp.samps)~ test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))

# this does a poor job representing d13 values by itself, but explains som of the variation
p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note better model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/d13C_intercept_mode/pred_vs_obs.png")
p.o.plot
dev.off()
 

png("outputs/growth_model/d13C_intercept_mode/marginal_alphas_v3_iWUE.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train.iso$struct.cohort)[order(unique(train.iso$struct.cohort.code))])))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("d13C")


ggplot(a.m, aes(variable, value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("d13C")

a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(full.iso$struct.cohort)[order(unique(full.iso$struct.cohort.code))])))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
a.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated mean D13C")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

a.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

a.dots <- ggplot(plot.dat.a, aes(x = a.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+xlim(-26, -22)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Mean d13C")

png(height = 5, width = 12, units = "in",res = 300,"outputs/growth_model/d13C_intercept_mode/d13C_alpha_marginal_distn_bycohort.png")
plot_grid(a.dots, a.mplots+coord_flip()+ xlim(-26, -22)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.75))
dev.off()

library(cowplot)
png(width = 7, height = 3, units = "in", res = 300, "outputs/growth_model/d13C_intercept_mode/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes.png")
plot_grid(alpha.mplots, ncol = 1)
dev.off()




plot.dat.a$ageclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.a$ageclass <- factor(plot.dat.a$ageclass, levels = c("Past", "Modern"))

plot.dat.a$forestclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")

a.dots.2 <- ggplot(plot.dat.a, aes(x = a.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+xlim(-26, -22)+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.text.x = element_blank())+xlab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)")))+facet_wrap(~forestclass)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13C_intercept_mode/param_marginal_distn_bycohort_struct_v3_d13_random_slopes.png")
a.dots.2
dev.off()


png(width = 7, height = 3, units = "in", res = 300, "outputs/growth_model/d13C_intercept_mode/param_marginal_distn_bycohort_struct_v3_d13_random_slopes_bw.png")
plot_grid(a.dots.2 + theme_bw(base_size = 14)+theme(legend.position = "none"), ncol = 1)
dev.off()

```

# intercept and VPDmax model for d13C:

```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
d13_VPD_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for iWUE:
d13[i]   ~ dnorm(d13func[i], inv.var) # where Yi is already log transformed

# function g()
d13func[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*VPD_scaled[i]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
}



# use normal hyperpriors for each hyperparamters 

mu_beta1 ~ dnorm(0, 0.1)
mu_beta2 ~ dnorm(0, 0.1)


inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)

inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)



# Non-informative Prior for the inverse population variances

inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


# Predict test data
for(i in 1:np){
# process model for iWUE:
d13.p[i]   ~ dnorm(d13func.p[i], inv.var) # where Yi is already log transformed

# function g()
d13func.p[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*VPD_scaled.p[i]

}


}"



d13_vpd <- jags.model(textConnection(d13_VPD_re), 
                    data = list(d13 = train.iso[!train.iso$site %in% "BON",]$Cor.d13C.suess, n=length(train.iso[!train.iso$site %in% "BON",]$iWUE), struct.cohort = as.numeric(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), SF = unique(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), VPD_scaled = train.iso[!train.iso$site %in% "BON",]$jja.VPDmax.scaled, np = length(test.iso[!test.iso$site %in% "BON",]$site), struct.cohort.p = as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code), VPD_scaled.p = test.iso[!test.iso$site %in% "BON",]$jja.VPDmax.scaled), n.chains = 3, n.adapt = 100)

update(d13_vpd, 1000); # Burnin for 1000 samples to start, then go higher later


d13.mean.re <- coda.samples(d13_vpd, 
                     variable.names=c("beta1", "beta2","mu_beta1","mu_beta2", "d13.p"), 
                    n.chains = 3, n.iter = 20000, thin = 15)

summary(d13.mean.re )
plot(d13.mean.re )

gelman.diag(d13.mean.re )
acfplot(d13.mean.re )

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- d13.mean.re [[1]]
 saveRDS(samps, "outputs/growth_model/d13_VPD/samps.d13_nobon.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1:4]
 beta.samps  <- samps[,5:8]
d13.samps  <- samps[,9:(8+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]
 #d13p.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]


 #------------------ plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(d13.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess

pred.obs <- summary(lm(colMeans(Yp.samps)~ test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))

# this does a poor job representing d13 values by itself, but explains som of the variation
p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=-22, y=-26)

# note better model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/d13_VPD/pred_vs_obs.png")
p.o.plot
dev.off()

# ----------------- Plot intercepts/params ---------------------

png("outputs/growth_model/d13_VPD/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()


png("outputs/growth_model/d13_VPD/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(beta.samps[,1], main = "alpha Past-Savanna")
hist(beta.samps[,2], main = "alpha Modern-Savanna")
hist(beta.samps[,3],  main = "alpha Past-Forest")
hist(beta.samps[,4],  main = "alpha Modern-Forest")

dev.off()

# -----------plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c("Past-Forest", "Modern-Forest", "Past-Savanna", "Modern-Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")


ggplot(a.m, aes(variable, value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")

a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
a.mplots <-ggplot(a.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',

"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))


# for VPD:
b <- data.frame(beta.samps)
colnames(b) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b$num <- rownames(b)
b.m <- melt(b, id.vars=c("num"))
b.mplots <-ggplot(b.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated VPDmax Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))



# calculate dot plots
a.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.a$ageclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.a$ageclass <- factor(plot.dat.a$ageclass, levels = c("Past", "Modern"))
plot.dat.a$forestclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


a.dots.2 <- ggplot(plot.dat.a, aes(x = a.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+xlim(-25.5, -22)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_VPD/param_marginal_distn_bycohort_struct_v3_d13_random_slopes.png")
a.dots.2
dev.off()


b.mean <- apply(as.matrix(b[,1:4]), 2, mean)
b.lower <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b.upper <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b <- data.frame(b.mean, b.lower, b.upper)
plot.dat.b$class <- row.names(plot.dat.b)
plot.dat.b$class <- factor(plot.dat.b$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b$ageclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b$ageclass <- factor(plot.dat.b$ageclass, levels = c("Past", "Modern"))
plot.dat.b$forestclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b.dots.2 <- ggplot(plot.dat.b, aes(x = b.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b.lower, xmax = b.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.25, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_VPD/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_VPD_impact.png")
b.dots.2
dev.off()

```

# intercept VPDmax and DBH  model for d13C:

```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
d13_VPD_DBH_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for iWUE:
d13[i]   ~ dnorm(d13func[i], inv.var) # where Yi is already log transformed

# function g()
d13func[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*VPD_scaled[i] + beta3[struct.cohort[i]]*DBH_scaled[i]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
}



# use normal hyperpriors for each hyperparamters 

mu_beta1 ~ dnorm(0, 0.1)
mu_beta2 ~ dnorm(0, 0.1)
mu_beta3 ~ dnorm(0, 0.1)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)

inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)

inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)



# Non-informative Prior for the inverse population variances

inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


# Predict test data
for(i in 1:np){
# process model for iWUE:
d13.p[i]   ~ dnorm(d13func.p[i], inv.var) # where Yi is already log transformed

# function g()
d13func.p[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*VPD_scaled.p[i]+ beta3[struct.cohort.p[i]]*DBH_scaled.p[i]

}


}"



d13_vpd_dbh <- jags.model(textConnection(d13_VPD_DBH_re), 
                    data = list(d13 = train.iso[!train.iso$site %in% "BON",]$Cor.d13C.suess, n=length(train.iso[!train.iso$site %in% "BON",]$iWUE), struct.cohort = as.numeric(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), SF = unique(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), VPD_scaled = train.iso[!train.iso$site %in% "BON",]$jja.VPDmax.scaled, DBH_scaled = train.iso[!train.iso$site %in% "BON",]$DBH.scaled, np = length(test.iso[!test.iso$site %in% "BON",]$site), struct.cohort.p = as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code), VPD_scaled.p = test.iso[!test.iso$site %in% "BON",]$jja.VPDmax.scaled, DBH_scaled.p = test.iso[!test.iso$site %in% "BON",]$DBH.scaled), n.chains = 3, n.adapt = 100)

update(d13_vpd_dbh, 1000); # Burnin for 1000 samples to start, then go higher later


d13.mean.re <- coda.samples(d13_vpd_dbh, 
                     variable.names=c("beta1", "beta2","beta3","mu_beta1","mu_beta2","mu_beta3", "d13.p"), 
                    n.chains = 3, n.iter = 20000, thin = 15)

summary(d13.mean.re )
plot(d13.mean.re )

gelman.diag(d13.mean.re )
acfplot(d13.mean.re )

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- d13.mean.re [[1]]
 saveRDS(samps, "outputs/growth_model/d13_VPD_DBH/samps.d13_nobon.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1:4]
 beta.samps  <- samps[,5:8]
 beta2.samps  <- samps[,9:12]
d13.samps  <- samps[,13:(12+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]
 #d13p.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]


 #------------------ plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(d13.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess

pred.obs <- summary(lm(colMeans(Yp.samps)~ test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))

# this does a poor job representing d13 values by itself, but explains som of the variation
p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=-22, y=-26)

# note fairly poor model fit
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/d13_VPD_DBH/pred_vs_obs.png")
p.o.plot
dev.off()

# ----------------- Plot intercepts/params ---------------------

png("outputs/growth_model/d13_VPD_DBH/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()


png("outputs/growth_model/d13_VPD/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(beta.samps[,1], main = "alpha Past-Savanna")
hist(beta.samps[,2], main = "alpha Modern-Savanna")
hist(beta.samps[,3],  main = "alpha Past-Forest")
hist(beta.samps[,4],  main = "alpha Modern-Forest")

dev.off()

# -----------plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c("Past-Forest", "Modern-Forest", "Past-Savanna", "Modern-Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")


ggplot(a.m, aes(variable, value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")

a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
a.mplots <-ggplot(a.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',

"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))


# for VPD:
b <- data.frame(beta.samps)
colnames(b) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b$num <- rownames(b)
b.m <- melt(b, id.vars=c("num"))
b.mplots <-ggplot(b.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated VPDmax Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))


# for DBH:
b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <-ggplot(b2.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated DBH Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))


# calculate dot plots
a.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.a$ageclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.a$ageclass <- factor(plot.dat.a$ageclass, levels = c("Past", "Modern"))
plot.dat.a$forestclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


a.dots.2 <- ggplot(plot.dat.a, aes(x = a.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+xlim(-25.5, -22)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_VPD/param_marginal_distn_bycohort_struct_v3_d13_random_slopes.png")
a.dots.2
dev.off()

# dot plot for VPD
b.mean <- apply(as.matrix(b[,1:4]), 2, mean)
b.lower <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b.upper <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b <- data.frame(b.mean, b.lower, b.upper)
plot.dat.b$class <- row.names(plot.dat.b)
plot.dat.b$class <- factor(plot.dat.b$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b$ageclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b$ageclass <- factor(plot.dat.b$ageclass, levels = c("Past", "Modern"))
plot.dat.b$forestclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b.dots.2 <- ggplot(plot.dat.b, aes(x = b.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b.lower, xmax = b.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.25, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_VPD/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_VPD_impact.png")
b.dots.2
dev.off()

# dot plot for DBH
b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)
plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels = c("Past", "Modern"))
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.7, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_VPD/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_DBH_impact.png")
b.dots.2
dev.off()

```

# intercept total precip and VPDmax  model for d13C:
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
d13_MAP_tmax_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for iWUE:
d13[i]   ~ dnorm(d13func[i], inv.var) # where Yi is already log transformed

# function g()
d13func[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*MAP_scaled[i] + beta3[struct.cohort[i]]*TMAX_scaled[i]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
}



# use normal hyperpriors for each hyperparamters 

mu_beta1 ~ dnorm(0, 0.1)
mu_beta2 ~ dnorm(0, 0.1)
mu_beta3 ~ dnorm(0, 0.1)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)

inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)

inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)



# Non-informative Prior for the inverse population variances

inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


# Predict test data
for(i in 1:np){
# process model for iWUE:
d13.p[i]   ~ dnorm(d13func.p[i], inv.var) # where Yi is already log transformed

# function g()
d13func.p[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*MAP_scaled.p[i]+ beta3[struct.cohort.p[i]]*TMAX_scaled.p[i]

}


}"



d13_map_tmax <- jags.model(textConnection(d13_MAP_tmax_re), 
                    data = list(d13 = train.iso[!train.iso$site %in% "BON",]$Cor.d13C.suess, n=length(train.iso[!train.iso$site %in% "BON",]$iWUE), struct.cohort = as.numeric(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), SF = unique(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), MAP_scaled = train.iso[!train.iso$site %in% "BON",]$MAP.scaled, TMAX_scaled = train.iso[!train.iso$site %in% "BON",]$T.scaled, np = length(test.iso[!test.iso$site %in% "BON",]$site), struct.cohort.p = as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code), MAP_scaled.p = test.iso[!test.iso$site %in% "BON",]$MAP.scaled, TMAX_scaled.p = test.iso[!test.iso$site %in% "BON",]$T.scaled), n.chains = 3, n.adapt = 100)

update(d13_map_tmax, 1000); # Burnin for 1000 samples to start, then go higher later


d13_map_tmax.re <- coda.samples(d13_map_tmax, 
                     variable.names=c("beta1", "beta2","beta3","mu_beta1","mu_beta2","mu_beta3", "d13.p"), 
                    n.chains = 3, n.iter = 20000, thin = 15)

summary(d13_map_tmax.re )
plot(d13.meand13_map_tmax.re )

gelman.diag(d13_map_tmax.re )
acfplot(d13_map_tmax.re )

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- d13.mean.re [[1]]
 saveRDS(samps, "outputs/growth_model/d13_MAP_TMAX/samps.d13_nobon.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1:4]
 beta.samps  <- samps[,5:8]
 beta2.samps  <- samps[,9:12]
d13.samps  <- samps[,13:(12+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]
 #d13p.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]


 #------------------ plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(d13.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess

pred.obs <- summary(lm(colMeans(Yp.samps)~ test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))

# this does a poor job representing d13 values by itself, but explains som of the variation
p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=-22, y=-26)

# note fairly poor model fit
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX/pred_vs_obs.png")
p.o.plot
dev.off()

# ----------------- Plot intercepts/params ---------------------

png("outputs/growth_model/d13_MAP_TMAX/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()


png("outputs/growth_model/d13_MAP_TMAX/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(beta.samps[,1], main = "alpha Past-Savanna")
hist(beta.samps[,2], main = "alpha Modern-Savanna")
hist(beta.samps[,3],  main = "alpha Past-Forest")
hist(beta.samps[,4],  main = "alpha Modern-Forest")

dev.off()

# -----------plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c("Past-Forest", "Modern-Forest", "Past-Savanna", "Modern-Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")


ggplot(a.m, aes(variable, value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")

a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
a.mplots <-ggplot(a.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',

"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))


# for MAP:
b <- data.frame(beta.samps)
colnames(b) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b$num <- rownames(b)
b.m <- melt(b, id.vars=c("num"))
b.mplots <-ggplot(b.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated Precip Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))


# for DBH:
b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <-ggplot(b2.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated Tmax Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))


# calculate dot plots
a.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.a$ageclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.a$ageclass <- factor(plot.dat.a$ageclass, levels = c("Past", "Modern"))
plot.dat.a$forestclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


a.dots.2 <- ggplot(plot.dat.a, aes(x = a.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+xlim(-25.5, -22)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX/param_marginal_distn_bycohort_struct_v3_d13_random_slopes.png")
a.dots.2
dev.off()

# dot plot for MAP
b.mean <- apply(as.matrix(b[,1:4]), 2, mean)
b.lower <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b.upper <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b <- data.frame(b.mean, b.lower, b.upper)
plot.dat.b$class <- row.names(plot.dat.b)
plot.dat.b$class <- factor(plot.dat.b$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b$ageclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b$ageclass <- factor(plot.dat.b$ageclass, levels = c("Past", "Modern"))
plot.dat.b$forestclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b.dots.2 <- ggplot(plot.dat.b, aes(x = b.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b.lower, xmax = b.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.25, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_Precip_impact.png")
b.dots.2
dev.off()

# dot plot for DBH
b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)
plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels = c("Past", "Modern"))
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.7, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_TMAX_impact.png")
b2.dots.2
dev.off()

```


# intercept total precip and VPDmax  model for d13C:
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
d13_MAP_tmax_dbh_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for iWUE:
d13[i]   ~ dnorm(d13func[i], inv.var) # where Yi is already log transformed

# function g()
d13func[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*MAP_scaled[i] + beta3[struct.cohort[i]]*TMAX_scaled[i] + beta4[struct.cohort[i]]*DBH_scaled[i]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
}



# use normal hyperpriors for each hyperparamters 

mu_beta1 ~ dnorm(0, 0.1)
mu_beta2 ~ dnorm(0, 0.1)
mu_beta3 ~ dnorm(0, 0.1)
mu_beta4 ~ dnorm(0, 0.1)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)

inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)

inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)

inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)

# Non-informative Prior for the inverse population variances

inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


# Predict test data
for(i in 1:np){
# process model for iWUE:
d13.p[i]   ~ dnorm(d13func.p[i], inv.var) # where Yi is already log transformed

# function g()
d13func.p[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*MAP_scaled.p[i]+ beta3[struct.cohort.p[i]]*TMAX_scaled.p[i]+ beta4[struct.cohort.p[i]]*DBH_scaled.p[i]

}


# Probe values
for(i in 1:nprobe){
# process model for iWUE:
d13.probe[i]   ~ dnorm(d13func.probe[i], inv.var) # where Yi is already log transformed

# function g()
d13func.probe[i] <- beta1[struct.cohort.probe[i]] + beta2[struct.cohort.probe[i]]*MAP_scaled.probe[i]+ beta3[struct.cohort.probe[i]]*TMAX_scaled.probe[i]+ beta4[struct.cohort.probe[i]]*DBH_scaled.probe[i]

}

}"


# create probe to generate posterior predictions:
MAP.probe <- seq(range(full.iso$MAP.scaled)[1], range(full.iso$MAP.scaled)[2], by = 1)
T.probe <- seq(range(full.iso$T.scaled)[1], range(full.iso$T.scaled)[2], by = 1)
DBH.probe <- seq(range(full.iso$DBH.scaled)[1], range(full.iso$T.scaled)[2], by = 1)

d13probe <- expand.grid(MAP.probe = MAP.probe, T.probe = T.probe, DBH.probe = DBH.probe, struct.cohort.probe = 1:4)

d13_map_tmax <- jags.model(textConnection(d13_MAP_tmax_dbh_re), 
                    data = list(d13 = train.iso[!train.iso$site %in% "BON",]$Cor.d13C.suess, n=length(train.iso[!train.iso$site %in% "BON",]$iWUE), struct.cohort = as.numeric(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), SF = unique(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), MAP_scaled = train.iso[!train.iso$site %in% "BON",]$MAP.scaled, TMAX_scaled = train.iso[!train.iso$site %in% "BON",]$T.scaled, DBH_scaled = train.iso[!train.iso$site %in% "BON",]$DBH.scaled, np = length(test.iso[!test.iso$site %in% "BON",]$site), struct.cohort.p = as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code), MAP_scaled.p = test.iso[!test.iso$site %in% "BON",]$MAP.scaled, TMAX_scaled.p = test.iso[!test.iso$site %in% "BON",]$T.scaled, DBH_scaled.p = test.iso[!test.iso$site %in% "BON",]$DBH.scaled, 
                                nprobe = length(d13probe$MAP.probe),
                                MAP_scaled.probe = d13probe$MAP.probe,
                                TMAX_scaled.probe = d13probe$T.probe, 
                                DBH_scaled.probe = d13probe$DBH.probe,
                                struct.cohort.probe = d13probe$struct.cohort.probe), n.chains = 3, n.adapt = 100)

update(d13_map_tmax, 1000); # Burnin for 1000 samples to start, then go higher later


d13_map_tmax.re <- coda.samples(d13_map_tmax, 
                     variable.names=c("beta1", "beta2","beta3","beta4","mu_beta1","mu_beta2","mu_beta3","mu_beta4", "d13.p", "d13.probe"), 
                    n.chains = 3, n.iter = 20000, thin = 15)

summary( d13_map_tmax.re )
plot(d13.meand13_map_tmax.re )

gelman.diag(d13_map_tmax.re )
acfplot(d13_map_tmax.re )

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- d13_map_tmax.re [[1]]
 saveRDS(samps, "outputs/growth_model/d13_MAP_TMAX_dbh/samps.d13_nobon.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1:4]
 beta.samps  <- samps[,5:8]
 beta2.samps  <- samps[,9:12]
 beta3.samps  <- samps[,13:16]
 d13.samps  <- samps[,17:(16+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]
 d13p.samps  <- samps[,(17+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess)):(16+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess)+length(d13probe$MAP.probe))]
 #d13p.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]


 #------------------ plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(d13.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess

pred.obs <- summary(lm(colMeans(Yp.samps)~ test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))

# this does a poor job representing d13 values by itself, but explains som of the variation
p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=-22, y=-26)

# note fairly poor model fit
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/pred_vs_obs.png")
p.o.plot
dev.off()

# ----------------- Plot intercepts/params ---------------------

png("outputs/growth_model/d13_MAP_TMAX_dbh/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()


png("outputs/growth_model/d13_MAP_TMAX_dbh/marginal_alphas_v3_d13.png")
par(mfrow=c(3,2))
hist(beta.samps[,1], main = "alpha Past-Savanna")
hist(beta.samps[,2], main = "alpha Modern-Savanna")
hist(beta.samps[,3],  main = "alpha Past-Forest")
hist(beta.samps[,4],  main = "alpha Modern-Forest")

dev.off()

# -----------plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c("Past-Forest", "Modern-Forest", "Past-Savanna", "Modern-Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")


ggplot(a.m, aes(variable, value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")

a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
a.mplots <-ggplot(a.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',

"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))


# for MAP:
b <- data.frame(beta.samps)
colnames(b) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b$num <- rownames(b)
b.m <- melt(b, id.vars=c("num"))
b.mplots <-ggplot(b.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated Precip Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))


# for Tmax:
b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <-ggplot(b2.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated Tmax Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))

# for DBH:
b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <-ggplot(b3.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated Tmax Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))

# calculate dot plots
a.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.a$ageclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.a$ageclass <- factor(plot.dat.a$ageclass, levels = c("Past", "Modern"))
plot.dat.a$forestclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


a.dots.2 <- ggplot(plot.dat.a, aes(x = a.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+xlim(-25.5, -22)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX/param_marginal_distn_bycohort_struct_v3_d13_random_slopes.png")
a.dots.2
dev.off()

# dot plot for MAP
b.mean <- apply(as.matrix(b[,1:4]), 2, mean)
b.lower <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b.upper <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b <- data.frame(b.mean, b.lower, b.upper)
plot.dat.b$class <- row.names(plot.dat.b)
plot.dat.b$class <- factor(plot.dat.b$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b$ageclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b$ageclass <- factor(plot.dat.b$ageclass, levels = c("Past", "Modern"))
plot.dat.b$forestclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b.dots.2 <- ggplot(plot.dat.b, aes(x = b.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b.lower, xmax = b.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.25, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_Precip_impact.png")
b.dots.2
dev.off()

# dot plot for Tmax
b2.mean <- apply(as.matrix(b2[,1:4]), 2, mean)
b2.lower <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b2.upper <- apply(as.matrix(b2[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b2 <- data.frame(b2.mean, b2.lower, b2.upper)
plot.dat.b2$class <- row.names(plot.dat.b2)
plot.dat.b2$class <- factor(plot.dat.b2$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b2$ageclass <- ifelse(plot.dat.b2$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b2$ageclass <- factor(plot.dat.b2$ageclass, levels = c("Past", "Modern"))
plot.dat.b2$forestclass <- ifelse(plot.dat.b2$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b2.dots.2 <- ggplot(plot.dat.b2, aes(x = b2.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b2.lower, xmax = b2.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.7, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_TMAX_impact.png")
b2.dots.2
dev.off()




# dot plot for DBH
b3.mean <- apply(as.matrix(b3[,1:4]), 2, mean)
b3.lower <- apply(as.matrix(b3[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b3.upper <- apply(as.matrix(b3[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b3 <- data.frame(b3.mean, b3.lower, b3.upper)
plot.dat.b3$class <- row.names(plot.dat.b3)
plot.dat.b3$class <- factor(plot.dat.b3$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))



plot.dat.b3$ageclass <- ifelse(plot.dat.b3$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b3$ageclass <- factor(plot.dat.b3$ageclass, levels = c("Past", "Modern"))
plot.dat.b3$forestclass <- ifelse(plot.dat.b3$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b3.dots.2 <- ggplot(plot.dat.b3, aes(x = b3.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b3.lower, xmax = b3.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("d13C")+facet_wrap(~forestclass)+xlim(-0.7, 1)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_DBH_impact.png")
b3.dots.2
dev.off()




# ---------- make marginal plots of probed data -------------
# plot probed values of tree growth predictions:
Yprobe <- data.frame(d13p.samps)
colnames(Yprobe) <- 1:length(Yprobe)
probe.m <- melt(Yprobe)
 
colnames(probe.m) <- c("num", "d13pred")

d13probe$num <- 1:length(d13probe[,1])
#colnames(full.p) <- c("MA","SP06", "DBH","Log_lag_RWI_1", "struct.cohort", "num")

# summarize by structure + cohort class only:
d13probe$num <- as.factor(as.character(d13probe$num))
probtest <- dplyr::inner_join(probe.m, d13probe, by=c("num"))

prob <- probtest


struc.conversion <- data.frame(struct.cohort.probe = 1:4, cohort = c(paste0(c(unique(train.iso$struct.cohort)))))
 struc.conversion$ageclass <- ifelse(struc.conversion$cohort %in% c("Past-Forest", "Past-Savanna"), "Past", "Modern")

 prob <- left_join(prob, struc.conversion, by  = "struct.cohort.probe")

 preds_ci <- prob %>% group_by( MAP.probe, T.probe, DBH.probe,  struct.cohort.probe) %>% dplyr::summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.025), Ci.high = quantile(d13pred, 0.975))


 # convert to unscaled data:
 prob$MAP <- round(unscale(prob$MAP.probe, MAP.scaled))
 prob$Tmax <- round(unscale(prob$T.probe, T.scaled))
 prob$DBH <- round(unscale(prob$DBH.probe, DBH.scaled))

 #--------------- plot marginal effects of climate and DBH on d13 ----------------

 

 
 # Marginal MAP effect:
preds_ci_mod_past_MAP <- prob %>% group_by( MAP, ageclass) %>% summarise(meanY = mean(d13pred),                                                                           Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))

Y_MAP_marg <- ggplot(preds_ci_mod_past_MAP, aes(MAP,meanY, color = ageclass)) + geom_line()+#geom_smooth(data = preds_ci_mod_past_MAP, aes(x = MAP, y = meanY, se = FALSE)) + 
  geom_ribbon(data = preds_ci_mod_past_MAP,aes(x = MAP, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+ scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)"))) +xlab("Total Annual Precipitation (mm)")+theme_bw()


# marginal TMAX effect
preds_ci_mod_past_Tmax <- prob %>% group_by( Tmax,ageclass) %>% summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))

Y_Tmax_marg <- ggplot(preds_ci_mod_past_Tmax, aes(Tmax, meanY, color = ageclass))+geom_line()+geom_ribbon(data = preds_ci_mod_past_Tmax, aes(x = Tmax, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)"))) +xlab("Max. Temp. (DegF)")+theme_bw()

# marginal DBH effect
preds_ci_mod_past_DBH <- prob %>% group_by( DBH,ageclass) %>% summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))

Y_DBH_marg <- ggplot(preds_ci_mod_past_DBH, aes(DBH, meanY, color = ageclass))+geom_line()+geom_ribbon(data = preds_ci_mod_past_DBH, aes(x = DBH, ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, colour = NA)+scale_color_manual (values = c("Modern" = "red", "Past" = "blue")) + ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)"))) + xlab("Tree DBH (cm)")+theme_bw()


png(height = 7, width = 4, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/marginal_post_predictive_effects_ageclass.png")
legend <- get_legend(Y_MAP_marg)
plts <- plot_grid(Y_MAP_marg+theme(legend.position = "none"), Y_Tmax_marg+theme(legend.position = "none"), Y_DBH_marg+theme(legend.position = "none"), align = "v", ncol = 1)
plot_grid(plts, legend, ncol = 2, rel_widths = c(1, 0.35))
dev.off()


# --------------plot marginal effects for each stand structure and cohort class:
# plot marginal effects of climate and previous years growth 
# Marginal MAP effect:
preds_ci_mod_past_MAP <- prob %>% group_by( MAP, cohort) %>% summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))

Y_MAP_marg_c <- ggplot(preds_ci_mod_past_MAP, aes(MAP,meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_MAP, aes(x = MAP, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+ ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)")))+xlab("Total Precipitation")


# marginal TMAX effect
preds_ci_mod_past_Tmax <- prob %>% group_by( Tmax, cohort) %>% summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))

Y_Tmax_marg_c <- ggplot(preds_ci_mod_past_Tmax, aes(Tmax,meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_Tmax, aes(x = Tmax, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+ ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)"))) +xlab("Max. Temperature (DegF)")

# marginal DBH effect
preds_ci_mod_past_DBH <- prob %>% group_by( DBH, cohort) %>% summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))

Y_DBH_marg_c <- ggplot(preds_ci_mod_past_DBH, aes(DBH, meanY, color = cohort))+geom_line()+geom_ribbon(data = preds_ci_mod_past_DBH, aes(x = DBH, ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, colour = NA)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571')) +scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+  ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)")))+xlab("Tree DBH (cm)")

png(height = 7, width = 5, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/marginal_post_predictive_effects_ageclassXStruct.png")
legend <- get_legend(Y_MAP_marg_c)
plts <- plot_grid(Y_MAP_marg_c+theme(legend.position = "none"), Y_Tmax_marg_c+theme(legend.position = "none"), Y_DBH_marg_c+theme(legend.position = "none"), align = "v", ncol = 1)
plot_grid(plts, legend, ncol = 2, rel_widths = c(1, 0.45))
dev.off()



#------------ plot d13 responses to cliamte conditional on DBH and other climate:
preds_ci_all <- prob %>% group_by(DBH, MAP, Tmax, struct.cohort.probe, cohort) %>% dplyr::summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))

preds_ci_all_age <- prob %>% group_by(DBH, MAP, Tmax, ageclass) %>% dplyr::summarise(meanY = mean(d13pred),
                                                                            Ci.low = quantile(d13pred, 0.05), Ci.high = quantile(d13pred, 0.95))



# --------filter select some DBH values and low and high temps by cohort and stucture class ----


prob_select <- preds_ci_all %>% dplyr::filter(DBH == 16 | DBH == 48 | DBH == 79 , Tmax == 72 | Tmax == 90  ) 


prob_select$DBH<- as.numeric(prob_select$DBH)
prob_select$Tmax<- as.numeric(prob_select$Tmax)


Drought.resp.DBH.temp.cohort <- ggplot(prob_select, aes(MAP, meanY, color = cohort))+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = cohort), alpha = 0.25, linetype = "dashed", colour = NA)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))+scale_color_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))+facet_grid(vars(DBH), vars(Tmax),labeller = label_both)+ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)")))+xlab("Precipitation index")+theme_bw()


# output the above plots to PNG:
png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/MAP_response_high_temp_low_high_DBH_cohortXstruct.png")
Drought.resp.DBH.temp.cohort 
dev.off()

# --------filter select some DBH values and low and high temps by cohort/age class ----

prob_select <- preds_ci_all_age %>% dplyr::filter(DBH == 16 | DBH == 48 | DBH == 79 , Tmax == 72 | Tmax == 90  ) 


prob_select$DBH<- as.numeric(prob_select$DBH)
prob_select$Tmax<- as.numeric(prob_select$Tmax)


Drought.resp.DBH.temp.age <- ggplot(prob_select, aes(MAP, meanY, color = ageclass))+geom_line()+geom_ribbon(aes(ymin = Ci.low, ymax = Ci.high, fill = ageclass), alpha = 0.25, linetype = "dashed", colour = NA)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+scale_fill_manual(values = c("Past"='blue',"Modern"='red'))+facet_grid(vars(DBH), vars(Tmax), labeller=label_both)+ylab(expression(paste("Estimated " ,delta^{13}, "C (\u2030)")))+xlab("Precipitation index")+theme_bw()

png(height = 10, width = 8, units = "in", res = 300, "outputs/growth_model/d13_MAP_TMAX_dbh/MAP_response_high_temp_low_high_DBH_ageclass.png")
Drought.resp.DBH.temp.age
dev.off()
```


# intercept only model (mean for iWUE):

```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
iWUE_intercept_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for iWUE:
iWUE[i]   ~ dnorm(iwuefunc[i], inv.var) # where Yi is already log transformed

# function g()
iwuefunc[i] <- beta1[struct.cohort[i]]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
}



# use normal hyperpriors for each hyperparamters 

mu_beta1 ~ dnorm(0, 0.1)


inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)



# Non-informative Prior for the inverse population variances

inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


# Predict test data
for(i in 1:np){
# process model for iWUE:
iWUE.p[i]   ~ dnorm(iwuefunc.p[i], inv.var) # where Yi is already log transformed

# function g()
iwuefunc.p[i] <- beta1[struct.cohort.p[i]]

}


}"



iwue_mean <- jags.model(textConnection(iWUE_intercept_re), 
                    data = list(iWUE = train.iso[!train.iso$site %in% "BON",]$iWUE, n=length(train.iso[!train.iso$site %in% "BON",]$iWUE), struct.cohort = as.numeric(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), SF = unique(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), np = length(test.iso[!test.iso$site %in% "BON",]$site), struct.cohort.p = as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code)), n.chains = 3, n.adapt = 100)

update(iwue_mean, 1000); # Burnin for 1000 samples to start, then go higher later


iwue.mean.re <- coda.samples(iwue_mean, 
                     variable.names=c("beta1", "mu_beta1", "iWUE.p"), 
                    n.chains = 3, n.iter = 20000, thin = 15)

summary(iwue.mean.re )
plot(iwue.mean.re )

gelman.diag(iwue.mean.re )
acfplot(iwue.mean.re )

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- iwue.mean.re [[1]]
 saveRDS(samps, "outputs/growth_model/iWUE_intercept_mod/samps.d13_nobon.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1:4]
alpha.samps  <- samps[,1:4]
iWUE.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]
 #d13p.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]


 #------------------ plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(iWUE.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test.iso[!test.iso$site %in% "BON",]$iWUE

pred.obs <- summary(lm(colMeans(Yp.samps)~ test.iso[!test.iso$site %in% "BON",]$iWUE))

# this does a poor job representing d13 values by itself, but explains som of the variation
p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note better model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/iWUE_intercept_mod/pred_vs_obs.png")
p.o.plot
dev.off()

# ----------------- Plot intercepts/params ---------------------

png("outputs/growth_model/iWUE_intercept_mod/marginal_alphas_v3_iWUE.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c("Past-Forest", "Modern-Forest", "Past-Savanna", "Modern-Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")


ggplot(a.m, aes(variable, value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")

a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(full.iso$struct.cohort)[order(unique(full.iso$struct.cohort.code))])))

a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
a.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))

a.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))

a.dots <- ggplot(plot.dat.a, aes(x = a.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+xlim(100, 160)+theme_black(base_size = 16)+scale_color_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',
"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))+coord_flip()+theme(legend.position = "none")+xlab("Estimated Drought Sensitivity")

png(height = 5, width = 12, units = "in",res = 300,"outputs/growth_model/iWUE_intercept_mod/iwue_alpha_marginal_distn_bycohort.png")
plot_grid(a.dots, a.mplots+coord_flip()+ xlim(100, 160)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()), rel_widths = c(1,0.75))
dev.off()

library(cowplot)
png(width = 7, height = 3, units = "in", res = 300, "outputs/growth_model/iWUE_intercept_mod/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes.png")
plot_grid(alpha.mplots, ncol = 1)
dev.off()


plot.dat.a$ageclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.a$ageclass <- factor(plot.dat.a$ageclass, levels = c("Past", "Modern"))
plot.dat.a$forestclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


a.dots.2 <- ggplot(plot.dat.a, aes(x = a.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+xlim(100, 160)+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("iWUE")+facet_wrap(~forestclass)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/iWUE_intercept_mod/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes.png")
a.dots.2
dev.off()


```



# intercept and VPDmax models for mean iWUE:

```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
iWUE_VPD_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for iWUE:
iWUE[i]   ~ dnorm(iwuefunc[i], inv.var) # where Yi is already log transformed

# function g()
iwuefunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*VPD_scaled[i]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
}



# use normal hyperpriors for each hyperparamters 

mu_beta1 ~ dnorm(0, 0.1)
mu_beta2 ~ dnorm(0, 0.1)


inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)

inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)



# Non-informative Prior for the inverse population variances

inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)


# Predict test data
for(i in 1:np){
# process model for iWUE:
iWUE.p[i]   ~ dnorm(iwuefunc.p[i], inv.var) # where Yi is already log transformed

# function g()
iwuefunc.p[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*VPD_scaled.p[i]

}


}"



iwue_vpd <- jags.model(textConnection(iWUE_VPD_re), 
                    data = list(iWUE = train.iso[!train.iso$site %in% "BON",]$iWUE, n=length(train.iso[!train.iso$site %in% "BON",]$iWUE), struct.cohort = as.numeric(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), SF = unique(train.iso[!train.iso$site %in% "BON",]$struct.cohort.code), VPD_scaled = train.iso[!train.iso$site %in% "BON",]$jja.VPDmax.scaled, np = length(test.iso[!test.iso$site %in% "BON",]$site), struct.cohort.p = as.numeric(test.iso[!test.iso$site %in% "BON",]$struct.cohort.code), VPD_scaled.p = test.iso[!test.iso$site %in% "BON",]$jja.VPDmax.scaled), n.chains = 3, n.adapt = 100)

update(iwue_vpd, 1000); # Burnin for 1000 samples to start, then go higher later


iwue.mean.re <- coda.samples(iwue_vpd, 
                     variable.names=c("beta1", "beta2","mu_beta1","mu_beta2", "iWUE.p"), 
                    n.chains = 3, n.iter = 20000, thin = 15)

summary(iwue.mean.re )
plot(iwue.mean.re )

gelman.diag(iwue.mean.re )
acfplot(iwue.mean.re )

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- iwue.mean.re [[1]]
 saveRDS(samps, "outputs/growth_model/iWUE_VPD/samps.d13_nobon.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1:4]
 beta.samps  <- samps[,5:8]
 iWUE.samps  <- samps[,9:(8+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]
 #d13p.samps  <- samps[,5:(4+length(test.iso[!test.iso$site %in% "BON",]$Cor.d13C.suess))]


 #------------------ plot predicted vs observed and assess model fit:
Yp.samps <- data.frame(iWUE.samps) 
Yp.m <- melt(Yp.samps)
Yp.summary <- Yp.m %>% group_by(variable) %>% dplyr::summarise(Predicted = mean(value),
                                                  ci.hi = quantile(value,0.975),
                                                 ci.lo = quantile(value,0.025))
Yp.summary$Observed <- test.iso[!test.iso$site %in% "BON",]$iWUE

pred.obs <- summary(lm(colMeans(Yp.samps)~ test.iso[!test.iso$site %in% "BON",]$iWUE))

# this does a poor job representing d13 values by itself, but explains som of the variation
p.o.plot <- ggplot(Yp.summary, aes(Observed, Predicted))+geom_point(color = "black", size = 0.5)+geom_errorbar(data = Yp.summary,aes(ymin=ci.lo, ymax=ci.hi), color = "grey", alpha = 0.5)+geom_point(data = Yp.summary, aes(Observed, Predicted), color = "black", size = 0.5)+geom_abline(aes(slope = 1, intercept = 0), color = "red", linetype = "dashed")+geom_text(data=data.frame(pred.obs$r.squared), aes( label = paste("R^2: ", pred.obs$r.squared, sep="")),parse=T,x=1, y=7)

# note better model fit!
png(width = 6, height = 5, units = "in", res = 300, "outputs/growth_model/iWUE_VPD/pred_vs_obs.png")
p.o.plot
dev.off()

# ----------------- Plot intercepts/params ---------------------

png("outputs/growth_model/iWUE_VPD/marginal_alphas_v3_iWUE.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()


png("outputs/growth_model/iWUE_VPD/marginal_alphas_v3_iWUE.png")
par(mfrow=c(3,2))
hist(beta.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")

dev.off()
# -----------plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c("Past-Forest", "Modern-Forest", "Past-Savanna", "Modern-Savanna")))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")


ggplot(a.m, aes(variable, value, fill = variable))+geom_boxplot(alpha = 0.5)+theme_black()+ylab("frequency")+xlab("iWUE")

a <- data.frame(alpha.samps)
colnames(a) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
a.mplots <-ggplot(a.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',
"Modern-Savanna"='#dfc27d',

"Modern-Forest"='#c7eae5',
"Past-Forest"='#018571'))


# for VPD:
b <- data.frame(beta.samps)
colnames(b) <- c(paste0(c(unique(train$struct.cohort)[order(unique(train$struct.cohort.code))])))

b$num <- rownames(b)
b.m <- melt(b, id.vars=c("num"))
b.mplots <-ggplot(b.m, aes(value, 1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE)+theme_bw()+xlab("Estimated VPDmax Sensitivity")+theme_black(base_size = 16)+scale_fill_manual(values = c("Past-Savanna"='#a6611a',"Modern-Savanna"='#dfc27d',"Modern-Forest"='#c7eae5',"Past-Forest"='#018571'))



# calculate dot plots
a.mean <- apply(as.matrix(a[,1:4]), 2, mean)
a.lower <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
a.upper <- apply(as.matrix(a[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.a$ageclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.a$ageclass <- factor(plot.dat.a$ageclass, levels = c("Past", "Modern"))
plot.dat.a$forestclass <- ifelse(plot.dat.a$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


a.dots.2 <- ggplot(plot.dat.a, aes(x = a.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+xlim(100, 160)+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',
"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("iWUE")+facet_wrap(~forestclass)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/iWUE_intercept_mod/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes.png")
a.dots.2
dev.off()


b.mean <- apply(as.matrix(b[,1:4]), 2, mean)
b.lower <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.025)))
b.upper <- apply(as.matrix(b[,1:4]), 2, function(x) quantile(x, probs = c(0.975)))

## Combine both estimates
plot.dat.b <- data.frame(b.mean, b.lower, b.upper)
plot.dat.b$class <- row.names(plot.dat.b)
plot.dat.b$class <- factor(plot.dat.b$class, levels = c("Past-Forest", "Past-Savanna", "Modern-Forest", "Modern-Savanna"))




plot.dat.b$ageclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Past-Forest"), "Past", "Modern")
plot.dat.b$ageclass <- factor(plot.dat.b$ageclass, levels = c("Past", "Modern"))
plot.dat.b$forestclass <- ifelse(plot.dat.b$class %in% c("Past-Savanna", "Modern-Savanna"), "Savanna", "Forest")


b.dots.2 <- ggplot(plot.dat.b, aes(x = b.mean, y = ageclass, color = ageclass, size = 2))+geom_errorbarh( xmin = b.lower, xmax = b.upper, size = 2,height = 0)+geom_point()+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='blue',"Modern"='red'))+coord_flip()+theme(legend.position = "none", axis.title.x = element_blank())+xlab("iWUE")+facet_wrap(~forestclass)+xlim(-7.1, 1.4)

png(width = 5, height = 4, units = "in", res = 300, "outputs/growth_model/iWUE_intercept_mod/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes_VPD_impact.png")
b.dots.2
dev.off()

```



# more complicated teste models::

# adding a prediction for stable isotopes (d13C) from tree growth predictions
```{r}
# this model is specified in basically the same as the site level model, but we replace site with "cohort"
d13_model_structure_x_cohort_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){
# process model for growth:
Y[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- beta1 + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i]+ beta4[struct.cohort[i]]*jul.VPDmax[i] + beta5[struct.cohort[i]]*iWUE[i] # use Drought index as a scaled variable 

# if there is d13 data, then use Y[i] to predict
#if(d13index[i]){
 # process model for d13C:
 #Y[i]   ~ dnorm(d13func[i], inv.var13) # where Yi is already log transformed
 #d13func[i] <- beta1 + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i] #+ beta4[struct.cohort[i]]*RWI[i] + beta5[struct.cohort[i]]*jul.VPDmax[i]
#}


#res[i] <- Y[i] - gfunc[i]   
#emp.new[i] ~ dnorm(gfunc[i], sigma)
#res.new[i] <- emp.new[i] - gfunc[i]
}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
#beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
# if we assume WUE is known for each group:
#mu_beta2[s] <- gamma1 * exp(-v*iWUE[s])
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
beta5[s] ~ dnorm(mu_beta5, inv_beta5)
}


#gamma1 ~ dgamma(0.001, 0.001)
#v ~ dgamma(0.001, 0.001)

# model for stable isotopes:
#for(d in 1:n.d13){

  # process model for growth:
 # Y.d13[d]   ~ dnorm(gfuncd13[d], inv.var) # Model Yi using estimated parameter distributions 

  # function g()
  #gfuncd13[d] <- beta1[struct.cohort.d13[d]] + beta2[struct.cohort.d13[d]]*DI.scaled.d13[d] +         #  beta3[struct.cohort.d13[d]]*DBH.scaled.d13[d]   # use Drought index as a scaled variable 

 # process model for d13C:
 #d13[d]   ~ dnorm(d13func[d], inv.var13) # where Yi is already log transformed
 #d13func[d] <- beta.d131 + beta.d132*Y[d]

#}



# use normal hyperpriors for each hyperparamters 
beta1 ~ dnorm(0, 0.01)
#mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)
mu_beta5 ~ dunif(-2, 2)
#beta.d131 ~ dnorm(0, 2)
#beta.d132 ~ dnorm(0,2)

#inv_beta1   ~ dgamma(0.01, 0.01)
#sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.01, 0.01)
sigma_beta5 <- 1/sqrt(inv_beta5)

#inv.var13 ~ dgamma(0.01, 0.01)
#sigma_13 <- 1/sqrt(inv.var13)


# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)






}"


# read in the d13 data:


d13 <- read.csv("outputs/stable_isotopes/merged_d13_growth.csv")
d13 <- d13[!is.na(d13$DBH),]
Y.d13 <- log(d13$RWI)
Y.iwue <- d13$iWUE
#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass.d13 <- as.numeric( d13$ageclass)
Age.d13 <- as.numeric( d13$Age)
n.d13     <- length(d13$RWI)
DBH.d13 <- d13$DBH
d13$DBH.scaled = as.vector(scale(d13$DBH, center = TRUE, scale = TRUE))
d13$DI.scaled = as.vector(scale(d13$JJA.pdsi, center = TRUE, scale = TRUE))
site.d13 <- d13$site
SpecCode.d13 <- d13$SpecCode
plot.d13 <- unique(d13$site)
#need to define site level structures:
structure <- data.frame(site = c("AVO","BON","COR",  "ENG",  "GLA",  "GLL1", "GLL2", "GLL3","GLL4", "HIC",  "MOU",  "PLE",  "PVC",  "STC",  "TOW", "UNC" ),
                        structure = c("Forest", "Savanna", "Forest", "Forest", "Savanna", "Forest", "Savanna", "Savanna", "Forest", "Savanna", "Forest","Savanna", "Savanna", "Savanna", "Forest", "Savanna"))



#full.ghcn <- merge(full.ghcn, structure, by = "site")

full.ghcn$struct.cohort <- paste0(full.ghcn$ageclass,"-", full.ghcn$structure)
full.ghcn$struct.cohort.code <- ifelse(full.ghcn$struct.cohort %in% "Past-Forest", 1,
       ifelse(full.ghcn$struct.cohort %in% "Modern-Forest", 2, 
               ifelse(full.ghcn$struct.cohort %in% "Past-Savanna", 3,
                     ifelse(full.ghcn$struct.cohort %in% "Modern-Savanna", 4,"NA" ))))

full.ghcn <- merge(full.ghcn, d13[,c("site", "ID", "year","Cor.d13C.suess", "iWUE")], by = c("site", "ID", "year"), all.x = TRUE)
# read in VPD data and merge with full data:
full.prism <- read.csv("outputs/data/full_det_prism_rwi.csv")
full.ghcn <- merge(full.ghcn, full.prism[,c("year", "site", "ID", "VPDmax", "jja.VPDmax", "BAL", "jul.BAL", "jul.VPDmax")], by = c("year", "site", "ID"))
full.ghcn$jul.VPDmax.scaled <- as.numeric(scale(full.ghcn$jul.VPDmax))
full.ghcn$iWUE.scaled <- as.numeric(scale(full.ghcn$iWUE))
d13index <- !is.na(full.ghcn$Cor.d13C.suess)
# generate fake data to predict on:
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
n = length(full.ghcn$Cor.d13C.suess)


# split into testing and training:
library(caTools)
full.iso <- full.ghcn[!is.na(full.ghcn$iWUE),]
#full.iso <- full.ghcn
iWUE.med<- full.iso %>% group_by(struct.cohort, struct.cohort.code) %>% summarise(iWUEmean = median(iWUE, na.rm =TRUE))
msk <- sample.split( full.iso, SplitRatio = 3/4, group = NULL )

train <- full.iso[msk,]
test <- full.iso[!msk,]

d13.model.by_structure_x_cohort <- jags.model(textConnection(d13_model_structure_x_cohort_re), 
                    data = list(Y = full.iso$RWI, n=length(full.iso$RWI), DI.scaled = full.iso$DI.scaled, DBH.scaled = full.iso$DBH.scaled, jul.VPDmax = full.iso$jul.VPDmax.scaled, iWUE = full.iso$iWUE.scaled, struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(full.iso$struct.cohort.code)), n.chains = 3, n.adapt = 100)

update(d13.model.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


d13.structure.cohort.re <- coda.samples(d13.model.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3", "beta4", "beta5","sigma_beta2","sigma_beta3", "sigma_beta4","sigma_beta5"), 
                    n.chains = 3, n.iter = 200000, thin = 15)

summary(d13.structure.cohort.re)
plot(d13.structure.cohort.re)

gelman.diag(d13.structure.cohort.re)
acfplot(d13.structure.cohort.re)

#Extract the samples for each parameter for a basic exploration of effects

 samps       <- d13.structure.cohort.re[[1]]
 saveRDS(samps, "outputs/growth_model/d13_reg_struct_x_cohort/samps.wue.rds")
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 #d13pred <- samps
 alpha.samps  <- samps[,1]
 beta2.samps <- samps[,2:5]
 beta3.samps <- samps[,6:9]
 beta4.samps <- samps[,10:13]
 beta5.samps <- samps[,14:17]
 sigma.samps <- samps[,16]
 #sigma13.samps <- samps[,15]
 sigma_betas <- samps[,17:21]
 d13pred <- samps[,18:8228]
 #betad131.samps <- samps[,1]
 #betad132.samps <- samps[,2]

# plot marginal distributions of each parameter:
png("outputs/growth_model/d13_reg_struct_x_cohort/marginal_d13_sigmas_v3_iWUE.png")
par(mfrow=c(2,2))
#hist(betad131.samps, main = "alpha d13")
#hist(betad132.samps, main = "beta d13")
hist(sigma.samps, main = "sigma")
dev.off()

png("outputs/growth_model/d13_reg_struct_x_cohort/marginal_alphas_v3_iWUE.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/d13_reg_struct_x_cohort/marginal_beta1s_v3_IWUE.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta2 Past-Savanna")
hist(beta3.samps[,2], main = "beta2 Modern-Savanna")
hist(beta4.samps[,3],  main = "beta2 Past-Forest")
hist(beta2.samps[,4],  main = "beta2 Modern-Forest")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/d13_reg_struct_x_cohort/marginal_beta2s_v3_iwue.png")
par(mfrow=c(3,2))
hist(beta3.samps[,1], main = "beta3 Past-Savanna")
hist(beta3.samps[,2], main = "beta3 Modern-Savanna")
hist(beta3.samps[,3],  main = "beta3 Past-Forest")
hist(beta3.samps[,4],  main = "beta3 Modern-Forest")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(full.ghcn$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0("beta2-",c(unique(full.ghcn$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()


b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(full.ghcn$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta3-",c(unique(full.ghcn$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()

b5 <- data.frame(beta5.samps)
colnames(b5) <- c(paste0("beta5-",c(unique(full.ghcn$struct.cohort))))
b5$num <- rownames(b5)
b5.m <- melt(b5, id.vars=c("num"))
b5.mplots <- ggplot(b5.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()



library(cowplot)
png(width = 4, height = 8, units = "in", res = 300, "outputs/growth_model/d13_reg_struct_x_cohort/param_marginal_distn_bycohort_struct_v3_iwue_random_slopes.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots, b4.mplots, b5.mplots, ncol = 1)
dev.off()


#predict the 
# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 
beta131.mn <- mean(betad131.samps) 
beta132.mn <- mean(betad132.samps) 


# Plot the plug-in Posterior predictive denisty using "fake data"
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()

 d13pred <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   
   ypred[[j]]  <- rnorm(np, mu, sigma.mn)

   # make a prediction of d13 based on MU:
   
   
   
   d13func <- beta131.mn + beta132.mn*ypred[[j]]   # use
   d13pred[[j]]  <- d13func
   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)
d13pred.df <- do.call(rbind, d13pred)
#ypred.yp.df <- do.call(rbind, ypred.yp)
png("outputs/growth_model/d13_reg_struct_x_cohort/predicted_y_d13.png")
par(mfrow = c(1,2))
plot(density(ypred.df), main = "Ypred, line = Ydata")
abline(v = mean(Y), col = "red")

plot(density(d13pred.df), main = "d13pred, line = d13data")
abline(v= mean(d13$Cor.d13C.suess), col = "red")
dev.off()

# need to calculate pvalues

pval113.d <- mean(d13pred.df > d13$Cor.d13C.suess) 


Xp$MeanY <- exp(rowMeans(ypred.df))
Xp$Meand13<- rowMeans(d13pred.df)# get the means of the posterior to plot the overall effects of 
Xp$struct.cohort <- ifelse(Xp$struct.cohort == 1, "Past-Forest",  
                       ifelse(Xp$struct.cohort == 2, "Modern-Forest",
                               ifelse(Xp$struct.cohort == 3, "Past-Savanna", 
                                       ifelse(Xp$struct.cohort == 4, "Modern-Savanna", NA))))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

#png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(struct.cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
#dev.off()






#png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,Meand13, color = as.factor(struct.cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")+stat_smooth(method = "lm")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2, Meand13, color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted d13")+stat_smooth(method = "lm")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = Meand13))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
#dev.off()



```

```{r}
d13only_model_structure_x_cohort_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){

 d13[i]   ~ dnorm(d13func[i], inv.var13) # where Yi is already log transformed
 d13func[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i] + beta4[struct.cohort[i]]*VPD.max.scaled[i]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)
}




# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)
mu_beta5 ~ dunif(-2, 2)
beta.d131 ~ dnorm(0, 2)
beta.d132 ~ dnorm(0,2)

inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.01, 0.01)
sigma_beta5 <- 1/sqrt(inv_beta5)

# Non-informative Prior for the inverse population variances
inv.var13 ~ dgamma(0.01, 0.01)
sigma_13 <- 1/sqrt(inv.var13)


# Prediction using testing data
for(i in 1:np){

 d13.p[i]   ~ dnorm(d13func.p[i], inv.var13) # where Yi is already log transformed
 d13func.p[i] <- beta1[struct.cohort.p[i]] + beta2[struct.cohort.p[i]]*DI.scaled.p[i] + beta3[struct.cohort.p[i]]*DBH.scaled.p[i] + beta4[struct.cohort.p[i]]*VPD.max.scaled.p[i]

}

}"


# read in the d13 data:


d13 <- read.csv("outputs/stable_isotopes/merged_d13_growth.csv")
d13 <- d13[!is.na(d13$DBH),]
Y.d13 <- log(d13$RWI)
#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass.d13 <- as.numeric( d13$ageclass)
Age.d13 <- as.numeric( d13$Age)
n.d13     <- length(d13$RWI)
DBH.d13 <- d13$DBH
d13$DBH.scaled = as.vector(scale(d13$DBH, center = TRUE, scale = TRUE))
d13$DI.scaled = as.vector(scale(d13$JJA.pdsi, center = TRUE, scale = TRUE))
site.d13 <- d13$site
SpecCode.d13 <- d13$SpecCode
plot.d13 <- unique(d13$site)
#need to define site level structures:
structure <- data.frame(site = c("AVO","BON","COR",  "ENG",  "GLA",  "GLL1", "GLL2", "GLL3","GLL4", "HIC",  "MOU",  "PLE",  "PVC",  "STC",  "TOW", "UNC" ),
                        structure = c("Forest", "Savanna", "Forest", "Forest", "Savanna", "Forest", "Savanna", "Savanna", "Forest", "Savanna", "Forest","Savanna", "Savanna", "Savanna", "Forest", "Savanna"))



#full.ghcn <- merge(full.ghcn, structure, by = "site")

full.ghcn$struct.cohort <- paste0(full.ghcn$ageclass,"-", full.ghcn$structure)
full.ghcn$struct.cohort.code <- ifelse(full.ghcn$struct.cohort %in% "Past-Forest", 1,
       ifelse(full.ghcn$struct.cohort %in% "Modern-Forest", 2, 
               ifelse(full.ghcn$struct.cohort %in% "Past-Savanna", 3,
                     ifelse(full.ghcn$struct.cohort %in% "Modern-Savanna", 4,"NA" ))))

full.ghcn <- merge(full.ghcn, d13[,c("site", "ID", "year","Cor.d13C.suess", "iWUE")], by = c("site", "ID", "year"), all.x = TRUE)

d13index <- !is.na(full.ghcn$Cor.d13C.suess)
# generate fake data to predict on:
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)


d13.model.only.by_structure_x_cohort <- jags.model(textConnection(d13only_model_structure_x_cohort_re), 
                    data = list( n=length(train$DI.scaled), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), d13 = train$iWUE, VPD.max.scaled= train$jul.VPDmax.scaled, np=length(test$DI.scaled), DI.scaled.p = test$DI.scaled, DBH.scaled.p = test$DBH.scaled, struct.cohort.p = as.numeric(test$struct.cohort.code),  VPD.max.scaled.p= test$jul.VPDmax.scaled), n.chains = 3, n.adapt = 100)

update(d13.model.only.by_structure_x_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


d13.model.only.by_structure_x_cohort <- coda.samples(d13.model.only.by_structure_x_cohort, 
                     variable.names=c("beta1", "beta2","beta3","beta4", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4", "d13.p"), 
                    n.chains = 3, n.iter = 20000, thin = 10)

summary(d13.model.only.by_structure_x_cohort)
plot(d13.model.only.by_structure_x_cohort)

gelman.diag(d13.model.only.by_structure_x_cohort)
acfplot(d13.model.only.by_structure_x_cohort)

#Extract the samples for each parameter for a basic exploration of effects

samps       <- d13.model.only.by_structure_x_cohort[[1]]
saveRDS(samps,"outputs/growth_model/wue_reg_struct_x_cohort/samps.rds")
plot(d13.model.only.by_structure_x_cohort)

 
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 alpha.samps  <- samps[,1:4]
 beta2.samps <- samps[,5:8]
 beta3.samps <- samps[,9:12]
 beta4.samps <- samps[,13:16]
 iWUEpred.samps <- samps[,17:2801]
 #sigma13.samps <- samps[,15]
 #sigma_betas <- samps[,16:18]

 #betad131.samps <- samps[,1]
 #betad132.samps <- samps[,2]


png("outputs/growth_model/wue_reg_struct_x_cohort/marginal_alphas_v3.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/wue_reg_struct_x_cohort/marginal_beta1s_v3.png")
par(mfrow=c(3,2))
hist(beta1.samps[,1], main = "beta2 Past-Savanna")
hist(beta1.samps[,2], main = "beta2 Modern-Savanna")
hist(beta1.samps[,3],  main = "beta2 Past-Forest")
hist(beta1.samps[,4],  main = "beta2 Modern-Forest")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/wue_reg_struct_x_cohort/marginal_beta2s_v3.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta3 Past-Savanna")
hist(beta2.samps[,2], main = "beta3 Modern-Savanna")
hist(beta2.samps[,3],  main = "beta3 Past-Forest")
hist(beta2.samps[,4],  main = "beta3 Modern-Forest")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()++xlab("Intercepts for iWUE")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0("beta2-",c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("effect of Summer Drought")


b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("effect of Tree DBH")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("effect of July VPD")


library(cowplot)
png(width = 4, height = 8, units = "in", res = 300, "outputs/growth_model/wue_reg_struct_x_cohort/param_marginal_distn_bycohort_struct_v3.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, ncol = 1)
dev.off()


# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 
beta131.mn <- mean(betad131.samps) 
beta132.mn <- mean(betad132.samps) 


# Plot the plug-in Posterior predictive denisty using "fake data"
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 VPDprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,VPDprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()

 d13pred <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   
   ypred[[j]]  <- rnorm(np, mu, sigma.mn)

   # make a prediction of d13 based on MU:
   
   
   
   d13func <- beta131.mn + beta132.mn*ypred[[j]]   # use
   d13pred[[j]]  <- d13func
   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)
d13pred.df <- do.call(rbind, d13pred)
#ypred.yp.df <- do.call(rbind, ypred.yp)
png("outputs/growth_model/d13_reg_struct_x_cohort/predicted_y_d13.png")
par(mfrow = c(1,2))
plot(density(ypred.df), main = "Ypred, line = Ydata")
abline(v = mean(Y), col = "red")

plot(density(d13pred.df), main = "d13pred, line = d13data")
abline(v= mean(d13$Cor.d13C.suess), col = "red")
dev.off()

# need to calculate pvalues

pval113.d <- mean(d13pred.df > d13$Cor.d13C.suess) 


Xp$MeanY <- exp(rowMeans(ypred.df))
Xp$Meand13<- rowMeans(d13pred.df)# get the means of the posterior to plot the overall effects of 
Xp$struct.cohort <- ifelse(Xp$struct.cohort == 1, "Past-Forest",  
                       ifelse(Xp$struct.cohort == 2, "Modern-Forest",
                               ifelse(Xp$struct.cohort == 3, "Past-Savanna", 
                                       ifelse(Xp$struct.cohort == 4, "Modern-Savanna", NA))))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

#png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(struct.cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
#dev.off()






#png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,Meand13, color = as.factor(struct.cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")+stat_smooth(method = "lm")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2, Meand13, color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted d13")+stat_smooth(method = "lm")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = Meand13))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
#dev.off()



```
# cohort only model:

```{r}
d13only_model_cohort_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){

 d13[i]   ~ dnorm(d13func[i], inv.var) # where Yi is already log transformed
 d13func[i] <- beta1[cohort[i]]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
}


# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)


inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)


# Non-informative Prior for the inverse population variances
inv.var ~ dgamma(0.01, 0.01)
sigma <- 1/sqrt(inv.var)


# Prediction using testing data
for(i in 1:np){

 d13.p[i]   ~ dnorm(d13func.p[i], inv.var) # where Yi is already log transformed
 d13func.p[i] <- beta1[cohort.p[i]] 

}

}"


# read in the d13 data:


d13 <- read.csv("outputs/stable_isotopes/merged_d13_growth.csv")
d13 <- d13[!is.na(d13$DBH),]
Y.d13 <- log(d13$RWI)
#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass.d13 <- as.numeric( d13$ageclass)
Age.d13 <- as.numeric( d13$Age)
n.d13     <- length(d13$RWI)
DBH.d13 <- d13$DBH
d13$DBH.scaled = as.vector(scale(d13$DBH, center = TRUE, scale = TRUE))
d13$DI.scaled = as.vector(scale(d13$JJA.pdsi, center = TRUE, scale = TRUE))
site.d13 <- d13$site
SpecCode.d13 <- d13$SpecCode
plot.d13 <- unique(d13$site)

#need to define site level structures:
structure <- data.frame(site = c("AVO","BON","COR",  "ENG",  "GLA",  "GLL1", "GLL2", "GLL3","GLL4", "HIC",  "MOU",  "PLE",  "PVC",  "STC",  "TOW", "UNC" ),
                        structure = c("Forest", "Savanna", "Forest", "Forest", "Savanna", "Forest", "Savanna", "Savanna", "Forest", "Savanna", "Forest","Savanna", "Savanna", "Savanna", "Forest", "Savanna"))



#full.ghcn <- merge(full.ghcn, structure, by = "site")

full.ghcn$struct.cohort <- paste0(full.ghcn$ageclass,"-", full.ghcn$structure)
full.ghcn$struct.cohort.code <- ifelse(full.ghcn$struct.cohort %in% "Past-Forest", 1,
       ifelse(full.ghcn$struct.cohort %in% "Modern-Forest", 2, 
               ifelse(full.ghcn$struct.cohort %in% "Past-Savanna", 3,
                     ifelse(full.ghcn$struct.cohort %in% "Modern-Savanna", 4,"NA" ))))

full.ghcn <- merge(full.ghcn, d13[,c("site", "ID", "year","Cor.d13C.suess", "iWUE")], by = c("site", "ID", "year"), all.x = TRUE)


d13.model.only.by_cohort <- jags.model(textConnection(d13only_model_cohort_re), 
                    data = list( n=length(full.iso$DI.scaled), cohort = as.numeric(full.iso$ageclass), SF = unique(full.iso$ageclass), d13 = full.iso$Cor.d13C.suess,  np=length(test$DI.scaled),  cohort.p = as.numeric(test$ageclass)), n.chains = 3, n.adapt = 100)

update(d13.model.only.by_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


d13.model.only.by_structure_x_cohort <- coda.samples(d13.model.only.by_cohort, 
                     variable.names=c("beta1","sigma", "d13.p"), 
                    n.chains = 3, n.iter = 20000, thin = 10)

summary(d13.model.only.by_structure_x_cohort)
plot(d13.model.only.by_structure_x_cohort)

gelman.diag(d13.model.only.by_structure_x_cohort)
acfplot(d13.model.only.by_structure_x_cohort)

#Extract the samples for each parameter for a basic exploration of effects

samps       <- d13.model.only.by_structure_x_cohort[[1]]
saveRDS(samps,"outputs/growth_model/d13_reg_cohort/samps.rds")
plot(d13.model.only.by_structure_x_cohort)

 
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 d13.samps <- samps[,1:length(test$site)]
 alpha.samps  <- samps[,1:2]
 


png("outputs/growth_model/d13_reg_cohort/marginal_alphas_v3.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")

dev.off()




# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c("Modern", "Past")
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Intercepts for iWUE")


a.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.05)+theme_bw()+xlab("Estimated Drought Sensitivity")+theme_black(base_size = 18)+scale_fill_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))

a.mean <- apply(as.matrix(a[,1:2]), 2, mean)
a.lower <- apply(as.matrix(a[,1:2]), 2, function(x) quantile(x, probs = c(0.05)))
a.upper <- apply(as.matrix(a[,1:2]), 2, function(x) quantile(x, probs = c(0.95)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past", "Modern"))
a.dots <- ggplot(plot.dat.a, aes(x = a.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+xlim(-26, -22)+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))+coord_flip()+theme(legend.position = "none")+xlab("d13C")

png(height = 5, width = 8, units = "in", res = 300, "outputs/growth_model/d13_reg_cohort/drougt_beta_marginal_distn_bycohort.png")
plot_grid(a.dots+xlim(-26,-22), a.mplots+coord_flip()+xlim(-26,-22)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))
dev.off()


```
```{r}
iwueonly_model_cohort_re <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){

 d13[i]   ~ dnorm(d13func[i], inv.var) # where Yi is already log transformed
 d13func[i] <- beta1[cohort[i]]

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
}


# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)


inv_beta1   ~ dgamma(0.1, 0.1)
sigma_beta1 <- 1/sqrt(inv_beta1)


# Non-informative Prior for the inverse population variances
inv.var ~ dgamma(0.01, 0.01)
sigma <- 1/sqrt(inv.var)


# Prediction using testing data
for(i in 1:np){

 d13.p[i]   ~ dnorm(d13func.p[i], inv.var) # where Yi is already log transformed
 d13func.p[i] <- beta1[cohort.p[i]] 

}

}"


# read in the d13 data:


d13 <- read.csv("outputs/stable_isotopes/merged_d13_growth.csv")
d13 <- d13[!is.na(d13$DBH),]
Y.d13 <- log(d13$RWI)
#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass.d13 <- as.numeric( d13$ageclass)
Age.d13 <- as.numeric( d13$Age)
n.d13     <- length(d13$RWI)
DBH.d13 <- d13$DBH
d13$DBH.scaled = as.vector(scale(d13$DBH, center = TRUE, scale = TRUE))
d13$DI.scaled = as.vector(scale(d13$JJA.pdsi, center = TRUE, scale = TRUE))
site.d13 <- d13$site
SpecCode.d13 <- d13$SpecCode
plot.d13 <- unique(d13$site)
#need to define site level structures:
structure <- data.frame(site = c("AVO","BON","COR",  "ENG",  "GLA",  "GLL1", "GLL2", "GLL3","GLL4", "HIC",  "MOU",  "PLE",  "PVC",  "STC",  "TOW", "UNC" ),
                        structure = c("Forest", "Savanna", "Forest", "Forest", "Savanna", "Forest", "Savanna", "Savanna", "Forest", "Savanna", "Forest","Savanna", "Savanna", "Savanna", "Forest", "Savanna"))



#full.ghcn <- merge(full.ghcn, structure, by = "site")

full.ghcn$struct.cohort <- paste0(full.ghcn$ageclass,"-", full.ghcn$structure)
full.ghcn$struct.cohort.code <- ifelse(full.ghcn$struct.cohort %in% "Past-Forest", 1,
       ifelse(full.ghcn$struct.cohort %in% "Modern-Forest", 2, 
               ifelse(full.ghcn$struct.cohort %in% "Past-Savanna", 3,
                     ifelse(full.ghcn$struct.cohort %in% "Modern-Savanna", 4,"NA" ))))

full.ghcn <- merge(full.ghcn, d13[,c("site", "ID", "year","Cor.d13C.suess", "iWUE")], by = c("site", "ID", "year"), all.x = TRUE)


iwue.model.only.by_cohort <- jags.model(textConnection(iwueonly_model_cohort_re), 
                    data = list( n=length(full.iso$DI.scaled), cohort = as.numeric(full.iso$ageclass), SF = unique(full.iso$ageclass), d13 = full.iso$iWUE,  np=length(test$DI.scaled),  cohort.p = as.numeric(test$ageclass)), n.chains = 3, n.adapt = 100)

update(iwue.model.only.by_cohort, 1000); # Burnin for 1000 samples to start, then go higher later


iwue.model.only <- coda.samples(iwue.model.only.by_cohort, 
                     variable.names=c("beta1","sigma", "d13.p"), 
                    n.chains = 3, n.iter = 20000, thin = 10)

summary(iwue.model.only )
plot(iwue.model.only )

gelman.diag(iwue.model.only )
acfplot(iwue.model.only )

#Extract the samples for each parameter for a basic exploration of effects

samps       <- iwue.model.only[[1]]
saveRDS(samps,"outputs/growth_model/iwue_reg_cohort/samps.rds")
plot(d13.model.only.by_structure_x_cohort)

 
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 d13.samps <- samps[,1:length(test$site)]
 alpha.samps  <- samps[,1:2]
 


png("outputs/growth_model/iwue_reg_cohort/marginal_alphas_v3.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")

dev.off()




# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c("Modern", "Past")
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("Estimated iWUE")


a.mplots <-ggplot(a.m, aes(value,1, fill = variable))+stat_density_ridges(alpha = 0.5, quantile_lines = TRUE, quantiles = c(0.025, 0.975), bandwidth  = 0.5)+theme_bw()+xlab("Estimated iWUE")+theme_black(base_size = 18)+scale_fill_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))

a.mean <- apply(as.matrix(a[,1:2]), 2, mean)
a.lower <- apply(as.matrix(a[,1:2]), 2, function(x) quantile(x, probs = c(0.05)))
a.upper <- apply(as.matrix(a[,1:2]), 2, function(x) quantile(x, probs = c(0.95)))

## Combine both estimates
plot.dat.a <- data.frame(a.mean, a.lower, a.upper)
plot.dat.a$class <- row.names(plot.dat.a)
plot.dat.a$class <- factor(plot.dat.a$class, levels = c("Past", "Modern"))
a.dots <- ggplot(plot.dat.a, aes(x = a.mean, y = class, color = class, size = 2))+geom_errorbarh( xmin = a.lower, xmax = a.upper, size = 2,height = 0)+geom_point()+xlim(115, 160)+theme_black(base_size = 18)+scale_color_manual(values = c("Past"='#d73027',
"Modern"='#4575b4'))+coord_flip()+theme(legend.position = "none")+xlab("iWUE")

png(height = 5, width = 8, units = "in", res = 300, "outputs/growth_model/iwue_reg_cohort/drougt_beta_marginal_distn_bycohort.png")
plot_grid(a.dots+xlim(115, 160), a.mplots+coord_flip()+xlim(115, 160)+ylab("frequency")+theme(axis.title.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()))
dev.off()


```


# model growth and response to climate as a function of WUE:

```{r}
wue_model_structure_x_cohort_re_plot_effects <- "model{

# for each the overall population include re for sites:

# Likelihood
for(i in 1:n){

 iWUE[i]   ~ dnorm(gfunc[i], inv.var) # where Yi is already log transformed
 gfunc[i] <- beta1[struct.cohort[i]] + beta2[struct.cohort[i]]*DI.scaled[i] + beta3[struct.cohort[i]]*DBH.scaled[i] + beta4[struct.cohort[i]]*VPD.max.scaled[i] 

}


# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(SF)){
beta1[s] ~ dnorm(mu_beta1, inv_beta1)
beta2[s] ~ dnorm(mu_beta2, inv_beta2)
beta3[s] ~ dnorm(mu_beta3, inv_beta3)
beta4[s] ~ dnorm(mu_beta4, inv_beta4)

#mu_beta2[s] <- gam*exp(v*iWUE.dist[s])
#iWUE.dist[s] ~ dnorm(iWUE.data[s], sigma.WUE[s])

#gam ~ dnorm(0, 0.01)
#v ~ dnorm(0, 0.01)

}


#gam ~ dnorm(0, 0.01)
#v ~ dnorm(0, 0.01)

# use normal hyperpriors for each hyperparamters 
mu_beta1 ~ dunif(-2, 2)
mu_beta2 ~ dunif(-2, 2)
mu_beta3 ~ dunif(-2, 2)
mu_beta4 ~ dunif(-2, 2)
mu_beta5 ~ dunif(-2, 2)


inv_beta1   ~ dgamma(0.01, 0.01)
sigma_beta1 <- 1/sqrt(inv_beta1)
inv_beta2   ~ dgamma(0.01, 0.01)
sigma_beta2 <- 1/sqrt(inv_beta2)
inv_beta3   ~ dgamma(0.01, 0.01)
sigma_beta3 <- 1/sqrt(inv_beta3)
inv_beta4   ~ dgamma(0.01, 0.01)
sigma_beta4 <- 1/sqrt(inv_beta4)
inv_beta5   ~ dgamma(0.01, 0.01)
sigma_beta5 <- 1/sqrt(inv_beta5)

# Non-informative Prior for the inverse population variances
inv.var ~ dgamma(0.01, 0.01)
sigma <- 1/sqrt(inv.var)




}"


# read in the d13 data:


d13 <- read.csv("outputs/stable_isotopes/merged_d13_growth.csv")
d13 <- d13[!is.na(d13$DBH),]
Y.d13 <- log(d13$RWI)
#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass.d13 <- as.numeric( d13$ageclass)
Age.d13 <- as.numeric( d13$Age)
n.d13     <- length(d13$RWI)
DBH.d13 <- d13$DBH
d13$DBH.scaled = as.vector(scale(d13$DBH, center = TRUE, scale = TRUE))
d13$DI.scaled = as.vector(scale(d13$JJA.pdsi, center = TRUE, scale = TRUE))
site.d13 <- d13$site
SpecCode.d13 <- d13$SpecCode
plot.d13 <- unique(d13$site)


iwue.df<- full.ghcn %>% group_by(struct.cohort, struct.cohort.code) %>% summarise(iWUE.dat = median(iWUE, na.rm=TRUE), iwue.sd = sd(iWUE, na.rm = TRUE))

train.df <- merge(iwue.df, train, by = c("struct.cohort", "struct.cohort.code"))
#need to define site level structures:
structure <- data.frame(site = c("AVO","BON","COR",  "ENG",  "GLA",  "GLL1", "GLL2", "GLL3","GLL4", "HIC",  "MOU",  "PLE",  "PVC",  "STC",  "TOW", "UNC" ),
                        structure = c("Forest", "Savanna", "Forest", "Forest", "Savanna", "Forest", "Savanna", "Savanna", "Forest", "Savanna", "Forest","Savanna", "Savanna", "Savanna", "Forest", "Savanna"))



#full.ghcn <- merge(full.ghcn, structure, by = "site")

full.ghcn$struct.cohort <- paste0(full.ghcn$ageclass,"-", full.ghcn$structure)
full.ghcn$struct.cohort.code <- ifelse(full.ghcn$struct.cohort %in% "Past-Forest", 1,
       ifelse(full.ghcn$struct.cohort %in% "Modern-Forest", 2, 
               ifelse(full.ghcn$struct.cohort %in% "Past-Savanna", 3,
                     ifelse(full.ghcn$struct.cohort %in% "Modern-Savanna", 4,"NA" ))))

full.ghcn <- merge(full.ghcn, d13[,c("site", "ID", "year","Cor.d13C.suess", "iWUE")], by = c("site", "ID", "year"), all.x = TRUE)

d13index <- !is.na(full.ghcn$Cor.d13C.suess)
# generate fake data to predict on:
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)


d13.model.only.by_structure_x_cohort <- jags.model(textConnection(growth_wue_model_structure_x_cohort_re), 
                    data = list( n=length(train$DI.scaled), DI.scaled = train$DI.scaled, DBH.scaled = train$DBH.scaled, struct.cohort = as.numeric(train$struct.cohort.code), SF = unique(train$struct.cohort.code), Y = log(train$RWI), VPD.max.scaled= train$jul.VPDmax.scaled, iWUE.data = train.df$iWUE.dat, sigma.WUE = train.df$iwue.sd ), n.chains = 3, n.adapt = 100)

update(growth_wue_model_structure_x_cohort_re, 100); # Burnin for 1000 samples to start, then go higher later


d13.model.only.by_structure_x_cohort <- coda.samples(growth_wue_model_structure_x_cohort_re, 
                     variable.names=c("beta1", "beta2","beta3","beta4", "sigma_beta1", "sigma_beta2","sigma_beta3", "sigma_beta4", "v", "gam", "mu_beta2"), 
                    n.chains = 3, n.iter = 20000, thin = 10)

summary(d13.model.only.by_structure_x_cohort)
plot(d13.model.only.by_structure_x_cohort)

gelman.diag(d13.model.only.by_structure_x_cohort)
acfplot(d13.model.only.by_structure_x_cohort)

#Extract the samples for each parameter for a basic exploration of effects

samps       <- d13.model.only.by_structure_x_cohort[[1]]
saveRDS(samps,"outputs/growth_model/wue_reg_struct_x_cohort/samps.rds")
plot(d13.model.only.by_structure_x_cohort)

 
 #Yp.samps <- samps[,1:660] # one alpha for each of 16 sites
 alpha.samps  <- samps[,1:4]
 beta2.samps <- samps[,5:8]
 beta3.samps <- samps[,9:12]
 beta4.samps <- samps[,13:16]
 sigma.samps <- samps[,17:20]
 #sigma13.samps <- samps[,15]
 #sigma_betas <- samps[,16:18]

 #betad131.samps <- samps[,1]
 #betad132.samps <- samps[,2]


png("outputs/growth_model/wue_reg_struct_x_cohort/marginal_alphas_v3.png")
par(mfrow=c(3,2))
hist(alpha.samps[,1], main = "alpha Past-Savanna")
hist(alpha.samps[,2], main = "alpha Modern-Savanna")
hist(alpha.samps[,3],  main = "alpha Past-Forest")
hist(alpha.samps[,4],  main = "alpha Modern-Forest")
hist(sigma_betas[,1], main = "sigma alpha")
dev.off()

png("outputs/growth_model/wue_reg_struct_x_cohort/marginal_beta1s_v3.png")
par(mfrow=c(3,2))
hist(beta1.samps[,1], main = "beta2 Past-Savanna")
hist(beta1.samps[,2], main = "beta2 Modern-Savanna")
hist(beta1.samps[,3],  main = "beta2 Past-Forest")
hist(beta1.samps[,4],  main = "beta2 Modern-Forest")
hist(sigma_betas[,2], main = "sigma beta2")
dev.off()

png("outputs/growth_model/wue_reg_struct_x_cohort/marginal_beta2s_v3.png")
par(mfrow=c(3,2))
hist(beta2.samps[,1], main = "beta3 Past-Savanna")
hist(beta2.samps[,2], main = "beta3 Modern-Savanna")
hist(beta2.samps[,3],  main = "beta3 Past-Forest")
hist(beta2.samps[,4],  main = "beta3 Modern-Forest")
hist(sigma_betas[,3], main = "sigma beta3")
dev.off()


# plot marginal distributions of cohort + structure specific parameters:
a <- data.frame(alpha.samps)
colnames(a) <- c(paste0("alpha-",c(unique(train$struct.cohort))))
a$num <- rownames(a)
a.m <- melt(a, id.vars=c("num"))
alpha.mplots <- ggplot(a.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()++xlab("Intercepts for iWUE")


b2 <- data.frame(beta2.samps)
colnames(b2) <- c(paste0("beta2-",c(unique(train$struct.cohort))))
b2$num <- rownames(b2)
b2.m <- melt(b2, id.vars=c("num"))
b2.mplots <- ggplot(b2.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("effect of Summer Drought")


b3 <- data.frame(beta3.samps)
colnames(b3) <- c(paste0("beta3-",c(unique(train$struct.cohort))))
b3$num <- rownames(b3)
b3.m <- melt(b3, id.vars=c("num"))
b3.mplots <- ggplot(b3.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("effect of Tree DBH")

b4 <- data.frame(beta4.samps)
colnames(b4) <- c(paste0("beta4-",c(unique(train$struct.cohort))))
b4$num <- rownames(b4)
b4.m <- melt(b4, id.vars=c("num"))
b4.mplots <- ggplot(b4.m, aes(value, fill = variable))+geom_density(alpha = 0.5)+theme_bw()+xlab("effect of July VPD")


library(cowplot)
png(width = 4, height = 8, units = "in", res = 300, "outputs/growth_model/wue_reg_struct_x_cohort/param_marginal_distn_bycohort_struct_v3.png")
plot_grid(alpha.mplots, b2.mplots, b3.mplots,b4.mplots, ncol = 1)
dev.off()


# Compute the posterior mean for the plug-in predictions  

 beta1.mn  <- colMeans(beta1.samps)
 beta2.mn  <- colMeans(beta2.samps)
 sigma.mn <- mean(sigma.samps)
 alpha1.mn <- colMeans(alpha.samps) 
beta131.mn <- mean(betad131.samps) 
beta132.mn <- mean(betad132.samps) 


# Plot the plug-in Posterior predictive denisty using "fake data"
# want to plaot posteror predictive distributions:
 
# can probe either within the JAGS model or in R after the model runs:
 # specify "x probe" values for DBH + DI:
 #xprobe <- matrix(rep(-2.102618, 3.321394))
 DIprobe <- seq(range(DI.scaled)[1], range(DI.scaled)[2], by = 0.5)
 DBHprobe <- seq(range(DBH.scaled)[1], range(DBH.scaled)[2], by = 0.5)
 
 # something like:
full.probe <- expand.grid(DIprobe, DBHprobe,  struct.cohort= 1:4)
 # use these vals to get ypred
 # compare y pred to y acutal
 # for each value of DI and DBH and site, find the predicted growth based on the model:





 Xp <- full.probe
 np <- length(Xp$Var1)
 ypred <- list()

 d13pred <- list()
 for(j in 1:np){

   # PPD
   #plot(density(Yp.samps[,j]),xlab="Y",main="PPD")

   
   mu <- alpha1.mn[Xp[j,3]] + beta1.mn[Xp[j,3]]*Xp[j,1] + beta2.mn[Xp[j,3]]*Xp[j,2]   # use
   
   ypred[[j]]  <- rnorm(np, mu, sigma.mn)

   # make a prediction of d13 based on MU:
   
   
   
   d13func <- beta131.mn + beta132.mn*ypred[[j]]   # use
   d13pred[[j]]  <- d13func
   # Truth
   #abline(v=Y[j],col=3,lwd=2)

   #legend("topright",c("PPD","Plug-in","Truth"),col=1:3,lty=1,inset=0.05)
}

ypred.df <- do.call(rbind, ypred)
d13pred.df <- do.call(rbind, d13pred)
#ypred.yp.df <- do.call(rbind, ypred.yp)
png("outputs/growth_model/d13_reg_struct_x_cohort/predicted_y_d13.png")
par(mfrow = c(1,2))
plot(density(ypred.df), main = "Ypred, line = Ydata")
abline(v = mean(Y), col = "red")

plot(density(d13pred.df), main = "d13pred, line = d13data")
abline(v= mean(d13$Cor.d13C.suess), col = "red")
dev.off()

# need to calculate pvalues

pval113.d <- mean(d13pred.df > d13$Cor.d13C.suess) 


Xp$MeanY <- exp(rowMeans(ypred.df))
Xp$Meand13<- rowMeans(d13pred.df)# get the means of the posterior to plot the overall effects of 
Xp$struct.cohort <- ifelse(Xp$struct.cohort == 1, "Past-Forest",  
                       ifelse(Xp$struct.cohort == 2, "Modern-Forest",
                               ifelse(Xp$struct.cohort == 3, "Past-Savanna", 
                                       ifelse(Xp$struct.cohort == 4, "Modern-Savanna", NA))))
#DBH + DI on predicted growth

# Todo: unscale Drought and DBH indices

#png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,MeanY, color = as.factor(struct.cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2,MeanY,color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted growth")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = MeanY))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
#dev.off()






#png(height = 4, width = 6, units = "in", res = 200,filename= "/Users/kah/Documents/TreeRings/outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_struct_x_cohort.png")
ggplot(Xp, aes(Var1,Meand13, color = as.factor(struct.cohort)))+geom_point()+xlab("Drought Index")+ylab("predicted growth")+stat_smooth(method = "lm")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var2, Meand13, color = as.factor(struct.cohort)))+geom_point()+xlab("DBH Index")+ylab("predicted d13")+stat_smooth(method = "lm")
#dev.off()

#png(height = 4, width = 6, units = "in", res = 200,"outputs/growth_model/basic_reg_struct_x_cohort_re/Ypred_by_drought_DBH_struct_x_cohort.png")
ggplot(Xp, aes(Var1, Var2, fill = Meand13))+geom_raster()+xlab("Drought Index")+ylab("DBH Index")+scale_fill_distiller(palette = "BrBG", direction = -1)+facet_wrap(~as.factor(struct.cohort))
#dev.off()



```





## Bayesian heirarchical liner regression where alpha and beta coeffiencents are specific to savanna and forest cover:
# this model explores whether stand structure (savanna or forest) has an impact on the slope and intercept response to climate

```{r}


Y <- as.vector(log(full.ghcn$RWI)) 
# create table of savanna and forest

for.df <- data.frame(site = unique(full.ghcn$site), 
           fortype = c("forest", "savanna", "forest" ,"forest", "savanna", "forest", "savanna", "savanna", "forest", "savanna", "savanna", "savanna", "savanna", "savanna", "forest", "savanna"))

full.ghcn <- merge(full.ghcn, for.df, by = "site")
full.ghcn$fornum <- ifelse(full.ghcn$fortype %in% "forest", 1, 2)
# standardise predictor variables to have mean 0 and sd = 1
#DI.scaled = scale(full.ghcn$JJA.pdsi, center= TRUE, scale=TRUE)
#T.scaled = scale(full.ghcn$JUNTmax, center= TRUE, scale=TRUE)
#full.ghcn$DI.scaled = as.vector(scale(full.ghcn$JJA.pdsi, center = TRUE, scale = TRUE))
ggplot(full.ghcn, aes(DI.scaled,log(RWI), color = ageclass))+geom_point(size = 0.2)+geom_smooth(method = "lm")+facet_wrap(~fortype)


png(height= 5, width = 7, units = "in", res = 300, "outputs/two_age_class_logbai_past_mod.png")
ggplot(full.ghcn[full.ghcn$RWI <= 6200, ], aes(JJA.pdsi, log(RWI), color = ageclass))+geom_point(size = 0.02)+geom_smooth(method = "lm")+facet_wrap(~fortype)
dev.off()

#DI <- as.vector( full.ghcn$JJA.pdsi )
ageclass <- as.numeric( full.ghcn$ageclass)
Age <- as.numeric( full.ghcn$Age)
n     <- length(full.ghcn$RWI)
DBH <- full.ghcn$DBH.x
full.ghcn$DBH.scaled = as.vector(scale(full.ghcn$DBH.x, center = TRUE, scale = TRUE))
site <- full.ghcn$site
SpecCode <- full.ghcn$SpecCode

summary(lm(Y ~ log(DBH)))

summary(lm(Y ~ log(DBH) + log((pdsi + 10)/20) + log(JunTmax)  ))
summary(lmer(Y ~ DI.scaled+ (DI.scaled|ageclass)))
# population model for the response of each BAI to each year of climate:
population_model_age_class <- "model{

# for each type of stand structure:



# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[fortype[i]], inv.var) # where Yi is already log transformed

# function g()
gfunc[i] <- alpha[fortype[i]]+ beta2[fortype[i]] *DI.scaled[i]    # use Drought index as a scaled variable 
}



# Assume normal priors for betas, but generate a beta + alpha for each ageclass
for(s in 1:length(S)){
alpha[s] ~ dnorm(mu_alpha, inv_alpha)
beta2[s] ~ dnorm(mu_beta, inv_beta)
}

# use normal hyperpriors for each hyperparamters 
mu_alpha ~ dunif(-2, 2)
mu_beta ~ dunif(-2, 2)

inv_alpha   ~ dgamma(0.0001, 0.0001)
sigma_alpha <- 1/sqrt(inv_alpha)
inv_beta   ~ dgamma(0.001, 0.001)
sigma_beta <- 1/sqrt(inv_beta)



# Non-informative Prior for the inverse population variances

#alpha_ref ~ dnorm(0,0.1)
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)

}"

lmer.age <- lmer(Y ~ DI.scaled + (1|ageclass == 1))
ranef(lmer.age)
ggplot(full.ghcn[full.ghcn$RWI < 5500, ], aes(DBH.x, RWI , color = ageclass))+geom_point(size = 0.02)+stat_smooth(method = "lm")
indiv <- lmer(log(RWI) ~ DI.scaled + (DI.scaled|ID), data = full.ghcn)

initsList

# now 
reg.model.by_s <- jags.model(textConnection(population_model_age_class), 
                    data = list(Y=Y, n=n, DI.scaled = full.ghcn$DI.scaled, DBH.scaled = full.ghcn$DBH.scaled, fortype = ageclass, S = unique(ageclass)), n.chains = 3, n.adapt = 100)

update(reg.model.by_s, 40000); # Burnin for 1000 samples to start, then go higher later

samp <- coda.samples(reg.model.by_s, 
                     variable.names=c("beta", "beta2","alpha","sigma", "sigma_alpha"), 
                    n.chains = 3, n.iter=20000, thin = 10)

summary(samp)
gelman.diag(samp)
traceplot(samp)
plot(samp)

# quick check to see how params compare to OLS 
#summary(lm(Y ~ full.ghcn$DI.scaled))

# plot mcmc + the parameter distn
plot(samp)
gelman.diag(samp)
acfplot(samp, aspect = 2)


gelman.plot(samp)
# evaluate MCMC convergence:


# save a data frame with beta2 sensitivity and the 
samp.basic.reg.df <- summary(samp)
  
samp.basic.df.sum<- data.frame(mean = samp.df$statistics[2,"Mean"], 
           ci.low = samp.df$quantiles[2,"2.5%"], 
           ci.high = samp.df$quantiles[2,"97.5%"])
  



# lets do the model where stand only affects the slope and not the intercept, perhaps this will help it converge:

population_model_stand <- "model{

# for each type of stand structure:



# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[fortype[i]], inv.var) # where Yi is already log transformed


# function g()
gfunc[i] <- alpha +  beta[fortype[i]]*DI.scaled[i] # use Drought index as a scaled variable 
}

# Assume normal priors for betas, but generate a beta + alpha for each forest type s
for(s in 1:length(S)){

beta[s] ~ dnorm(mu_beta, inv_beta)
}

# use normal hyperpriors for each hyperparamters 
#mu_alpha ~ dnorm(0, 0.1)
mu_beta ~ dnorm(0, 0.1)

#inv_alpha   ~ dgamma(0.001, 0.001)
#sigma_alpha <- 1/sqrt(inv_alpha)
inv_beta   ~ dgamma(0.001, 0.001)
sigma_beta <- 1/sqrt(inv_beta)



# Non-informative Prior for the inverse population variances
inv.var   ~ dgamma(0.001, 0.001)
sigma     <- 1/sqrt(inv.var)
alpha ~ dnorm(0, 0.1)

}"

# now 
reg.model.by_s <- jags.model(textConnection(population_model_stand), 
                    data = list(Y=Y, n=n, DI.scaled = full.ghcn$DI.scaled, fortype =    full.ghcn$fornum, S = unique(full.ghcn$fornum)))

update(reg.model.by_s, 1000); # Burnin for 1000 samples to start, then go higher later

samp <- coda.samples(reg.model.by_s, 
                     variable.names=c("beta","alpha", "sigma"), 
                    n.chains = 4, n.iter=20000)

summary(samp)



```
# this model assumes all trees across all species + sites have the same relationship with summer PDSI + JUNTmax

```{r}
summary(full.ghcn)

full.ghcn <- full.ghcn[!is.na(full.ghcn$RWI) & full.ghcn$DBH.x > 0 & !is.na(full.ghcn$DBH.x),]
Y <- as.vector(log(full.ghcn$RWI)) 

pdsi <- as.vector( full.ghcn$JJA.pdsi)
JunTmax <- as.vector( full.ghcn$JUNTmax)
ageclass <- as.numeric( full.ghcn$ageclass)
Age <- as.numeric( full.ghcn$Age)
n     <- length(full.ghcn$RWI)
DBH <- full.ghcn$DBH.x

model_string_pdsi_tmax <- "model{

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var)

# function g()
gfunc[i] <- beta[1] +  beta[2]*pdsi[i] + beta[3]*JunTmax[i]
}

# Assume normal priors for betas (because they could be negative or positive)
for(j in 1:3){
beta[j] ~ dnorm(0,0.001)
}



# Prior for the inverse variances
inv.var   ~ dgamma(0.1, 0.1)
sigma     <- 1/sqrt(inv.var)



}"

reg.model.Drought.Tmax <- jags.model(textConnection(model_string_pdsi_tmax), 
                    data = list(Y=Y, n=n, pdsi = pdsi, JunTmax = JunTmax))

update(reg.model.Drought.Tmax, 10000, progress.bar="none"); # Burnin for 10000 samples

samp <- coda.samples(reg.model.Drought.Tmax, 
                     variable.names=c("beta","sigma"), 
                    n.chains = 3, n.iter=20000, progress.bar="none")

summary(samp)


# plot mcmc + the parameter distn
plot(samp)

# save a data frame with beta2 sensitivity and the 
samp.df <- summary(samp)
  
samps.df.sum<- data.frame(mean = samp.df$statistics[2,"Mean"], 
           ci.low = samp.df$quantiles[2,"2.5%"], 
           ci.high = samp.df$quantiles[2,"97.5%"])
  

ggplot(samps.df.sum, aes("sens",mean))+geom_bar(stat = "identity")+
  geom_errorbar(aes(ymin=ci.low, ymax = ci.high), size = 0.2, width = 0.2)

```


## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


# this model assumes all trees across all species + sites have the same relationship with summer PDSI + JUNTmax + DBH, but has a power function as the process model:



```{r}
summary(full.ghcn)

full.ghcn <- full.ghcn[!is.na(full.ghcn$RWI) & full.ghcn$DBH.x > 0 & !is.na(full.ghcn$DBH.x),]


Y <- as.vector(log(full.ghcn$RWI)) 

pdsi <- as.vector( full.ghcn$JJA.pdsi)
JunTmax <- as.vector( full.ghcn$JUNTmax)
ageclass <- as.numeric( full.ghcn$ageclass)
Age <- as.numeric( full.ghcn$Age)
n     <- length(full.ghcn$RWI)
DBH <- full.ghcn$DBH.x

model_string_DBH_power <- "model{

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var)

# function g()
gfunc[i] <- beta[1] +  beta[1]*log(DBH[i])
}

# Assume normal priors for betas (because they could be negative or positive)
#for(j in 1:2){
beta[1] ~ dnorm(0, 0.002)
beta[2] ~ dnormal(0, 0.002)
#}



# Prior for the inverse variances
inv.var   ~ dgamma(0.01, 0.01)
sigma     <- 1/sqrt(inv.var)


}"

reg.model.dbh.power <- jags.model(textConnection(model_string_DBH_power), 
                    data = list(Y=Y, n=n, DBH = DBH))

update(reg.model.dbh.power, 1000); # Burnin for 1000 samples

samp <- coda.samples(reg.model.dbh.power, 
                     variable.names=c("beta","sigma"), 
                    n.chains = 3, n.iter=2000)

summary(samp)


# plot mcmc + the parameter distn
plot(samp)

# save a data frame with beta2 sensitivity and the 
samp.df <- summary(samp)
  
samp.dbh.pwr <- do.call(rbind.data.frame, samp)


# compare to the estimates from OLS:

summary(lm(Y ~ log(DBH)))
```
# this model assumes all trees across all species + sites have the same relationship with summer PDSI + JUNTmax + DBH, but has a power function as the process model:

```{r}
summary(full.ghcn)

full.ghcn <- full.ghcn[!is.na(full.ghcn$RWI) & full.ghcn$DBH.x > 0 & !is.na(full.ghcn$DBH.x),]
Y <- as.vector((full.ghcn$RWI)) 

pdsi <- as.vector( full.ghcn$JJA.pdsi)
JunTmax <- as.vector( full.ghcn$JUNTmax)
ageclass <- as.numeric( full.ghcn$ageclass)
Age <- as.numeric( full.ghcn$Age)
n     <- length(full.ghcn$RWI)
DBH <- full.ghcn$DBH.x

model_string_pdsi_tmax_DBH_power <- "model{

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dlnorm(gfunc[i], inv.var)

# function g()
gfunc[i] <- beta[1] +  beta[2]*log((pdsi[i]+10)/20) + beta[3]*log(JunTmax[i]) + beta[4]*log(DBH[i])
}

# Assume normal priors for betas (because they could be negative or positive)
for(j in 1:4){
beta[j] ~ dlnorm(0,0.001)
}



# Prior for the inverse variances
inv.var   ~ dgamma(0.1, 0.1)
sigma     <- 1/sqrt(inv.var)


}"

reg.model.Drought.Tmax.dbh.power <- jags.model(textConnection(model_string_pdsi_tmax_DBH_power), 
                    data = list(Y=Y, n=n, pdsi = pdsi, JunTmax = JunTmax, DBH = DBH))

update(reg.model.Drought.Tmax.dbh.powe, 10000, progress.bar="none"); # Burnin for 10000 samples

samp <- coda.samples(reg.model.Drought.Tmax.dbh, 
                     variable.names=c("beta","sigma"), 
                    n.chains = 3, n.iter=20000, progress.bar="none")

summary(samp)


# plot mcmc + the parameter distn
plot(samp)

# save a data frame with beta2 sensitivity and the 
samp.df <- summary(samp)
  

```
# model assumes a power function relationship between growth ~ beta0x(DBH^beta1)x(DBH^2^beta2)x(droghtindex^beta3)x(JunTmax^beta4)
# will need to scale pdsi such that: drought index == ((pdsi+10)/20)

```{r}
summary(full.ghcn)

full.ghcn <- full.ghcn[!is.na(full.ghcn$RWI) & full.ghcn$DBH.x > 0 & !is.na(full.ghcn$DBH.x),]
Y <- as.vector(log(full.ghcn$RWI)) 

pdsi <- as.vector( (full.ghcn$JJA.pdsi + 10)/20)
JunTmax <- as.vector( full.ghcn$JUNTmax)
ageclass <- as.numeric( full.ghcn$ageclass)
Age <- as.numeric( full.ghcn$Age)
n     <- length(full.ghcn$RWI)
DBH <- full.ghcn$DBH.x

model_string_pdsi_tmax_DBH <- "model{

# Likelihood
for(i in 1:n){
# process model
Y[i]   ~ dnorm(gfunc[i], inv.var)

# function g()
gfunc[i] <- beta[1] +  beta[2]*pdsi[i] + beta[3]*JunTmax[i] + beta[4]*DBH[i]
}

# Assume normal priors for betas (because they could be negative or positive)
for(j in 1:4){
beta[j] ~ dnorm(0,0.001)
}



# Prior for the inverse variances
inv.var   ~ dgamma(0.1, 0.1)
sigma     <- 1/sqrt(inv.var)



}"

reg.model.Drought.Tmax.dbh <- jags.model(textConnection(model_string_pdsi_tmax_DBH), 
                    data = list(Y=Y, n=n, pdsi = pdsi, JunTmax = JunTmax, DBH = DBH))

update(reg.model.Drought.Tmax.dbh, 10000, progress.bar="none"); # Burnin for 10000 samples

samp <- coda.samples(reg.model.Drought.Tmax.dbh, 
                     variable.names=c("beta","sigma"), 
                    n.chains = 3, n.iter=20000, progress.bar="none")

summary(samp)


# plot mcmc + the parameter distn
plot(samp)

# save a data frame with beta2 sensitivity and the 
samp.df <- summary(samp)
  

```

